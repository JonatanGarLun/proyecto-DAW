{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83c\udfae Battlebound Tactics \u00b6 Un RPG por turnos t\u00e1ctico desarrollado como proyecto final del CFGS de DAW por Jonatan Garc\u00eda Luna. \ud83d\udccc \u00bfQu\u00e9 es Battlebound Tactics? \u00b6 Battlebound Tactics es una aplicaci\u00f3n web que simula un juego de rol t\u00e1ctico de combates por turnos, inspirada en los RPG cl\u00e1sicos pero desarrollada con herramientas modernas como Django, HTML, CSS, JavaScript y Docker. En este juego, los jugadores crean su propio personaje, lo desarrollan, equipan habilidades, armas y accesorios \u00fanicos, y se enfrentan a enemigos con inteligencia artificial en un mapa dividido por regiones. El objetivo principal es proporcionar una experiencia estrat\u00e9gica, progresiva y divertida dentro de un mundo visualmente atractivo, accesible desde navegador y hecho para el disfrute de todos. \ud83e\udded \u00bfQu\u00e9 puedes encontrar en esta documentaci\u00f3n? \u00b6 Esta documentaci\u00f3n t\u00e9cnica est\u00e1 organizada para que desarrolladores, profesores o cualquier persona interesada pueda comprender el funcionamiento del proyecto a nivel estructural, t\u00e9cnico y funcional . \ud83d\udcc4 Estructura General Secci\u00f3n Descripci\u00f3n \ud83d\udce6 Modelos del Proyecto Explica cada modelo de Django y sus relaciones. \ud83d\udda5\ufe0f Vistas de Django Explicaci\u00f3n detallada de las views, rutas y flujos de usuario. \u2694\ufe0f L\u00f3gica del Combate Desglose detallado de toda la mec\u00e1nica de combate: m\u00f3dulos core/ y vista combate . \ud83e\udde9 API y Ranking Detalles del sistema de ranking y uso de endpoints externos. \ud83d\ude80 Despliegue C\u00f3mo levantar el proyecto localmente o en producci\u00f3n con Docker. \ud83e\uddfe Conclusiones Reflexiones sobre el desarrollo, dificultades y aprendizajes. \ud83d\udee0\ufe0f Tecnolog\u00edas principales utilizadas \u00b6 Backend: Python + Django (ORM para modelos, vistas l\u00f3gicas y sesi\u00f3n) Frontend: HTML + CSS + JavaScript (renderizado de estados, interfaz de combate, navegaci\u00f3n) Despliegue: Docker, Docker Compose, AWS EC2, dominio personalizado Extras: Pillow (gesti\u00f3n de im\u00e1genes), API externa para rankings, Sora AI para generaci\u00f3n visual \ud83c\udfaf Objetivos del proyecto \u00b6 Construir un sistema de combate por turnos con l\u00f3gica avanzada. Desarrollar personajes con progresi\u00f3n, niveles, equipo y habilidades. Implementar enemigos con IA reactiva. Crear una experiencia de juego completa: mapa, combate, ranking. Dise\u00f1ar una interfaz clara, jugable y atractiva. Documentar y desplegar en AWS. \ud83c\udfc1 Estado actual \u00b6 \u2705 Sistema de combate funcional \u2705 Interfaz completa \u2705 Registro de jugadores \u2705 Equipamiento y habilidades \u2705 Ranking de usuarios \u2705 Despliegue funcional con Docker \u274c PvP, tienda y m\u00fasica (recortado por tiempo / limitaciones de hosting) \ud83e\udd1d Autor y cr\u00e9ditos \u00b6 Proyecto realizado por Jonatan Garc\u00eda Luna , como parte del m\u00f3dulo Proyecto Integrado del CFGS en Desarrollo de Aplicaciones Web (DAW) en el I.E.S. Francisco Romero Vargas. Nota: Esta documentaci\u00f3n se ir\u00e1 ampliando continuamente. Todas las secciones est\u00e1n estructuradas para facilitar tanto la comprensi\u00f3n del c\u00f3digo como su mantenimiento o ampliaci\u00f3n futura.","title":"\ud83c\udfe0 Presentaci\u00f3n"},{"location":"#battlebound-tactics","text":"Un RPG por turnos t\u00e1ctico desarrollado como proyecto final del CFGS de DAW por Jonatan Garc\u00eda Luna.","title":"\ud83c\udfae Battlebound Tactics"},{"location":"#que-es-battlebound-tactics","text":"Battlebound Tactics es una aplicaci\u00f3n web que simula un juego de rol t\u00e1ctico de combates por turnos, inspirada en los RPG cl\u00e1sicos pero desarrollada con herramientas modernas como Django, HTML, CSS, JavaScript y Docker. En este juego, los jugadores crean su propio personaje, lo desarrollan, equipan habilidades, armas y accesorios \u00fanicos, y se enfrentan a enemigos con inteligencia artificial en un mapa dividido por regiones. El objetivo principal es proporcionar una experiencia estrat\u00e9gica, progresiva y divertida dentro de un mundo visualmente atractivo, accesible desde navegador y hecho para el disfrute de todos.","title":"\ud83d\udccc \u00bfQu\u00e9 es Battlebound Tactics?"},{"location":"#que-puedes-encontrar-en-esta-documentacion","text":"Esta documentaci\u00f3n t\u00e9cnica est\u00e1 organizada para que desarrolladores, profesores o cualquier persona interesada pueda comprender el funcionamiento del proyecto a nivel estructural, t\u00e9cnico y funcional . \ud83d\udcc4 Estructura General Secci\u00f3n Descripci\u00f3n \ud83d\udce6 Modelos del Proyecto Explica cada modelo de Django y sus relaciones. \ud83d\udda5\ufe0f Vistas de Django Explicaci\u00f3n detallada de las views, rutas y flujos de usuario. \u2694\ufe0f L\u00f3gica del Combate Desglose detallado de toda la mec\u00e1nica de combate: m\u00f3dulos core/ y vista combate . \ud83e\udde9 API y Ranking Detalles del sistema de ranking y uso de endpoints externos. \ud83d\ude80 Despliegue C\u00f3mo levantar el proyecto localmente o en producci\u00f3n con Docker. \ud83e\uddfe Conclusiones Reflexiones sobre el desarrollo, dificultades y aprendizajes.","title":"\ud83e\udded \u00bfQu\u00e9 puedes encontrar en esta documentaci\u00f3n?"},{"location":"#tecnologias-principales-utilizadas","text":"Backend: Python + Django (ORM para modelos, vistas l\u00f3gicas y sesi\u00f3n) Frontend: HTML + CSS + JavaScript (renderizado de estados, interfaz de combate, navegaci\u00f3n) Despliegue: Docker, Docker Compose, AWS EC2, dominio personalizado Extras: Pillow (gesti\u00f3n de im\u00e1genes), API externa para rankings, Sora AI para generaci\u00f3n visual","title":"\ud83d\udee0\ufe0f Tecnolog\u00edas principales utilizadas"},{"location":"#objetivos-del-proyecto","text":"Construir un sistema de combate por turnos con l\u00f3gica avanzada. Desarrollar personajes con progresi\u00f3n, niveles, equipo y habilidades. Implementar enemigos con IA reactiva. Crear una experiencia de juego completa: mapa, combate, ranking. Dise\u00f1ar una interfaz clara, jugable y atractiva. Documentar y desplegar en AWS.","title":"\ud83c\udfaf Objetivos del proyecto"},{"location":"#estado-actual","text":"\u2705 Sistema de combate funcional \u2705 Interfaz completa \u2705 Registro de jugadores \u2705 Equipamiento y habilidades \u2705 Ranking de usuarios \u2705 Despliegue funcional con Docker \u274c PvP, tienda y m\u00fasica (recortado por tiempo / limitaciones de hosting)","title":"\ud83c\udfc1 Estado actual"},{"location":"#autor-y-creditos","text":"Proyecto realizado por Jonatan Garc\u00eda Luna , como parte del m\u00f3dulo Proyecto Integrado del CFGS en Desarrollo de Aplicaciones Web (DAW) en el I.E.S. Francisco Romero Vargas. Nota: Esta documentaci\u00f3n se ir\u00e1 ampliando continuamente. Todas las secciones est\u00e1n estructuradas para facilitar tanto la comprensi\u00f3n del c\u00f3digo como su mantenimiento o ampliaci\u00f3n futura.","title":"\ud83e\udd1d Autor y cr\u00e9ditos"},{"location":"api/","text":"\ud83c\udf10 API y Sistema de Ranking \u00b6 Esta secci\u00f3n documenta en profundidad la API REST del proyecto y su integraci\u00f3n con el sistema de ranking mostrado en el frontend. Esta API permite acceder a los datos de los jugadores y visualizar un ranking din\u00e1mico ordenado por diferentes criterios como nivel, victorias, derrotas u oro. \ud83e\udde9 Estructura general de la API \u00b6 La API est\u00e1 construida usando Django REST Framework y expone un punto principal: /api/jugadores/ , correspondiente al modelo Jugador . \ud83d\udd17 URLs registradas ( urls.py ) \u00b6 /api/jugadores/ \u2192 gestionado por JugadorViewSet /api/ \u2192 ra\u00edz de la API, gestionado por ApiRootViewSet Estas rutas se registran mediante un DefaultRouter de DRF, lo que permite exponer autom\u00e1ticamente las rutas est\u00e1ndar de un ModelViewSet . \ud83d\udce6 Serializadores ( serializers.py ) \u00b6 Se definen serializadores para varios modelos ( Jugador , Enemigo , Jefe , Combate ) pero el \u00fanico que se utiliza en esta API es: JugadorSerializer : serializa todos los campos del modelo Jugador usando fields = '__all__' . Esto permite acceder de forma detallada a todos los atributos del jugador, aunque en la vista se formatea la salida manualmente. \ud83d\udd04 JugadorViewSet \u00b6 Tipo: ModelViewSet \u00b6 Permisos: IsAuthenticated (requiere autenticaci\u00f3n) \u00b6 Filtros: \u00b6 Ordenamiento ( filters.OrderingFilter ) Campos disponibles: id , nombre , victorias , derrotas , oro , nivel Orden por defecto: victorias descendente Paginaci\u00f3n: CursorPagination (recomendado para listas largas) \u00b6 M\u00e9todo personalizado: list() \u00b6 En lugar de usar el comportamiento por defecto de DRF, se personaliza la respuesta para estructurar los datos de los jugadores de forma espec\u00edfica. Cada jugador devuelto tiene esta estructura: id_jugador usuario : nombre de usuario de Django nombre_personaje alineacion oro estadisticas : diccionario con clase, nivel, experiencia, salud, energ\u00eda, ataque, defensa, velocidad victorias derrotas porcentaje_victorias : calculado din\u00e1micamente Este m\u00e9todo se adapta tanto si se usa paginaci\u00f3n como si no. \ud83d\udd0d ApiRootViewSet \u00b6 Devuelve un diccionario con enlaces a los recursos disponibles. En este caso, solo expone el endpoint jugadores . \ud83e\uddd1\u200d\ud83d\udcbb Integraci\u00f3n con el Frontend (ranking) \u00b6 El ranking se muestra en la p\u00e1gina ranking.html . Este utiliza un archivo JS ( llamada_api.js ) que accede a la API para cargar din\u00e1micamente el top 5 de jugadores seg\u00fan el criterio elegido. \ud83d\uddbc\ufe0f Plantilla ranking.html \u00b6 Usa una estructura CSS para mostrar tarjetas de jugadores llamativa al usuario. Contiene filtros visuales para alternar entre ordenamiento por: Nivel Victorias Derrotas Oro Cada vez que se pulsa un bot\u00f3n, se llama a la funci\u00f3n cargarRanking() con el criterio correspondiente. \ud83d\udcdc Script: llamada_api.js \u00b6 Este script realiza una petici\u00f3n as\u00edncrona a la API con ordenamiento din\u00e1mico seg\u00fan el bot\u00f3n pulsado. Por ejemplo: /api/jugadores/?ordering=-nivel /api/jugadores/?ordering=-victorias Flujo: \u00b6 Se obtiene el JSON de respuesta de la API. Se recorre el top 5 jugadores ( data.results o data.slice ). Se genera el HTML para cada uno: Imagen del personaje seg\u00fan su clase. Nombre del personaje y usuario. Dato destacado seg\u00fan el filtro activo. Porcentaje de victorias si se muestra por victorias. Esta l\u00f3gica convierte la API en un recurso interactivo y visual , lo que mejora la experiencia de usuario y evita recargar toda la p\u00e1gina al cambiar de filtro. \ud83d\udcc8 Escalabilidad \u00b6 El sistema de ranking est\u00e1 preparado para escalar gracias a: Uso de paginaci\u00f3n ( CursorPagination ) Serializaci\u00f3n parcial y adaptada a cliente Consultas optimizadas por ordenamiento en la base de datos Facilidad de integraci\u00f3n con asincron\u00eda (JavaScript din\u00e1mico) \ud83d\udccc Consideraciones finales \u00b6 Este m\u00f3dulo representa uno de los puntos fuertes del proyecto, ya que combina: Backend con Django REST Framework API autenticada y protegida Respuesta enriquecida con datos derivados (como el porcentaje de victorias) Frontend con actualizaci\u00f3n en tiempo real del ranking Adem\u00e1s, esta estructura puede reutilizarse f\u00e1cilmente para exponer otras entidades del juego, como enemigos, combates o estad\u00edsticas globales, con solo a\u00f1adir nuevos ViewSets y Serializers .","title":"\ud83e\udde9 API y Endpoints Externos"},{"location":"api/#api-y-sistema-de-ranking","text":"Esta secci\u00f3n documenta en profundidad la API REST del proyecto y su integraci\u00f3n con el sistema de ranking mostrado en el frontend. Esta API permite acceder a los datos de los jugadores y visualizar un ranking din\u00e1mico ordenado por diferentes criterios como nivel, victorias, derrotas u oro.","title":"\ud83c\udf10 API y Sistema de Ranking"},{"location":"api/#estructura-general-de-la-api","text":"La API est\u00e1 construida usando Django REST Framework y expone un punto principal: /api/jugadores/ , correspondiente al modelo Jugador .","title":"\ud83e\udde9 Estructura general de la API"},{"location":"api/#urls-registradas-urlspy","text":"/api/jugadores/ \u2192 gestionado por JugadorViewSet /api/ \u2192 ra\u00edz de la API, gestionado por ApiRootViewSet Estas rutas se registran mediante un DefaultRouter de DRF, lo que permite exponer autom\u00e1ticamente las rutas est\u00e1ndar de un ModelViewSet .","title":"\ud83d\udd17 URLs registradas (urls.py)"},{"location":"api/#serializadores-serializerspy","text":"Se definen serializadores para varios modelos ( Jugador , Enemigo , Jefe , Combate ) pero el \u00fanico que se utiliza en esta API es: JugadorSerializer : serializa todos los campos del modelo Jugador usando fields = '__all__' . Esto permite acceder de forma detallada a todos los atributos del jugador, aunque en la vista se formatea la salida manualmente.","title":"\ud83d\udce6 Serializadores (serializers.py)"},{"location":"api/#jugadorviewset","text":"","title":"\ud83d\udd04 JugadorViewSet"},{"location":"api/#tipo-modelviewset","text":"","title":"Tipo: ModelViewSet"},{"location":"api/#permisos-isauthenticated-requiere-autenticacion","text":"","title":"Permisos: IsAuthenticated (requiere autenticaci\u00f3n)"},{"location":"api/#filtros","text":"Ordenamiento ( filters.OrderingFilter ) Campos disponibles: id , nombre , victorias , derrotas , oro , nivel Orden por defecto: victorias descendente","title":"Filtros:"},{"location":"api/#paginacion-cursorpagination-recomendado-para-listas-largas","text":"","title":"Paginaci\u00f3n: CursorPagination (recomendado para listas largas)"},{"location":"api/#metodo-personalizado-list","text":"En lugar de usar el comportamiento por defecto de DRF, se personaliza la respuesta para estructurar los datos de los jugadores de forma espec\u00edfica. Cada jugador devuelto tiene esta estructura: id_jugador usuario : nombre de usuario de Django nombre_personaje alineacion oro estadisticas : diccionario con clase, nivel, experiencia, salud, energ\u00eda, ataque, defensa, velocidad victorias derrotas porcentaje_victorias : calculado din\u00e1micamente Este m\u00e9todo se adapta tanto si se usa paginaci\u00f3n como si no.","title":"M\u00e9todo personalizado: list()"},{"location":"api/#apirootviewset","text":"Devuelve un diccionario con enlaces a los recursos disponibles. En este caso, solo expone el endpoint jugadores .","title":"\ud83d\udd0d ApiRootViewSet"},{"location":"api/#integracion-con-el-frontend-ranking","text":"El ranking se muestra en la p\u00e1gina ranking.html . Este utiliza un archivo JS ( llamada_api.js ) que accede a la API para cargar din\u00e1micamente el top 5 de jugadores seg\u00fan el criterio elegido.","title":"\ud83e\uddd1\u200d\ud83d\udcbb Integraci\u00f3n con el Frontend (ranking)"},{"location":"api/#plantilla-rankinghtml","text":"Usa una estructura CSS para mostrar tarjetas de jugadores llamativa al usuario. Contiene filtros visuales para alternar entre ordenamiento por: Nivel Victorias Derrotas Oro Cada vez que se pulsa un bot\u00f3n, se llama a la funci\u00f3n cargarRanking() con el criterio correspondiente.","title":"\ud83d\uddbc\ufe0f Plantilla ranking.html"},{"location":"api/#script-llamada_apijs","text":"Este script realiza una petici\u00f3n as\u00edncrona a la API con ordenamiento din\u00e1mico seg\u00fan el bot\u00f3n pulsado. Por ejemplo: /api/jugadores/?ordering=-nivel /api/jugadores/?ordering=-victorias","title":"\ud83d\udcdc Script: llamada_api.js"},{"location":"api/#flujo","text":"Se obtiene el JSON de respuesta de la API. Se recorre el top 5 jugadores ( data.results o data.slice ). Se genera el HTML para cada uno: Imagen del personaje seg\u00fan su clase. Nombre del personaje y usuario. Dato destacado seg\u00fan el filtro activo. Porcentaje de victorias si se muestra por victorias. Esta l\u00f3gica convierte la API en un recurso interactivo y visual , lo que mejora la experiencia de usuario y evita recargar toda la p\u00e1gina al cambiar de filtro.","title":"Flujo:"},{"location":"api/#escalabilidad","text":"El sistema de ranking est\u00e1 preparado para escalar gracias a: Uso de paginaci\u00f3n ( CursorPagination ) Serializaci\u00f3n parcial y adaptada a cliente Consultas optimizadas por ordenamiento en la base de datos Facilidad de integraci\u00f3n con asincron\u00eda (JavaScript din\u00e1mico)","title":"\ud83d\udcc8 Escalabilidad"},{"location":"api/#consideraciones-finales","text":"Este m\u00f3dulo representa uno de los puntos fuertes del proyecto, ya que combina: Backend con Django REST Framework API autenticada y protegida Respuesta enriquecida con datos derivados (como el porcentaje de victorias) Frontend con actualizaci\u00f3n en tiempo real del ranking Adem\u00e1s, esta estructura puede reutilizarse f\u00e1cilmente para exponer otras entidades del juego, como enemigos, combates o estad\u00edsticas globales, con solo a\u00f1adir nuevos ViewSets y Serializers .","title":"\ud83d\udccc Consideraciones finales"},{"location":"conclusiones/","text":"\u2705 Conclusiones Finales \u00b6 El desarrollo de Battlebound Tactics ha supuesto un proceso intenso, desafiante y muy gratificante, en el que he abordado de forma integral el dise\u00f1o, construcci\u00f3n, pruebas y despliegue de una aplicaci\u00f3n web que combina los principios de desarrollo backend con una experiencia visual frontend envolvente, todo ello dentro de un sistema de combate t\u00e1ctico por turnos. \ud83d\udd0d Visi\u00f3n General del Trabajo Realizado \u00b6 Desde el inicio del proyecto, me propuse dise\u00f1ar un juego web completo con mec\u00e1nicas inspiradas en los RPG cl\u00e1sicos, que ofreciera al jugador una experiencia estrat\u00e9gica, envolvente y entretenida. El proyecto ha abarcado: La definici\u00f3n de una base de datos compleja con modelos como Jugador , Enemigo , Habilidad , Pasiva , Arma , Accesorio , y Combate . La creaci\u00f3n del sistema de combate por turnos m\u00e1s profundo que he desarrollado hasta la fecha, con IA enemiga, habilidades activas y pasivas, efectos de estado y estad\u00edsticas din\u00e1micas. El dise\u00f1o de una interfaz de usuario visualmente atractiva y coherente, basada en plantillas HTML, CSS personalizado y l\u00f3gica de interacci\u00f3n con JavaScript. La integraci\u00f3n de funcionalidades clave como: mapa interactivo, zonas de jefes, sistema de curaci\u00f3n, ranking de jugadores a trav\u00e9s de una API, gesti\u00f3n de equipo, habilidades, y registro/login personalizado con pasivas \u00fanicas. El uso de Docker para contenedorizaci\u00f3n y GitHub Actions para automatizar el despliegue en AWS , garantizando una entrega profesional del producto final. \u26a0\ufe0f Principales Dificultades \u00b6 Durante el desarrollo me enfrent\u00e9 a m\u00faltiples retos t\u00e9cnicos: L\u00f3gica compleja del combate : La cantidad de condiciones, efectos, turnos y ramificaciones del sistema de combate requiri\u00f3 un dise\u00f1o modular y cuidadoso. Resolver los efectos acumulativos, el flujo de los turnos, y la IA enemiga me exigi\u00f3 una gran precisi\u00f3n. Frontend avanzado : Aunque ten\u00eda m\u00e1s experiencia en backend, enfrentarme a interacciones complejas con JavaScript (como las animaciones del combate o las peticiones a la API) fue un desaf\u00edo que logr\u00e9 superar con investigaci\u00f3n y dedicaci\u00f3n constantes. Despliegue en AWS : El entorno gratuito de AWS present\u00f3 l\u00edmites de recursos que me obligaron a optimizar el proyecto, deshabilitando funciones no esenciales como la m\u00fasica de fondo para evitar saturar el servidor. Dise\u00f1o visual personalizado : Me propuse un dise\u00f1o muy espec\u00edfico para los mapas y pantallas, lo que implic\u00f3 muchas horas ajustando estilos CSS y capas visuales para que el resultado final fuese fiel a la idea original que ten\u00eda en mente. \ud83d\udcc8 Evoluci\u00f3n del Proyecto \u00b6 Si bien la planificaci\u00f3n inicial era ambiciosa, durante el desarrollo fue necesario realizar ajustes realistas. Algunas funcionalidades como el sistema de tiendas, combates PvP o inventario de objetos fueron finalmente descartadas, no por falta de capacidad, sino por una decisi\u00f3n de priorizar calidad sobre cantidad . Prefiero no incluir una funcionalidad que no est\u00e1 madura, que implementarla de forma incompleta o apresurada. Estos ajustes me permitieron centrarme en lo verdaderamente importante: un sistema de combate s\u00f3lido, una experiencia jugable clara, y una interfaz pulida. Cada modificaci\u00f3n que se hizo al plan inicial fue razonada, documentada y ejecutada con criterio. \u2705 Estado Final del Proyecto \u00b6 Actualmente, Battlebound Tactics incluye: Sistema completo de combate por turnos, con IA enemiga, efectos de estado, pasivas y habilidades. Progresi\u00f3n del jugador basada en experiencia, niveles, equipo y estad\u00edsticas calculadas din\u00e1micamente durante el combate. M\u00faltiples pantallas accesibles desde un men\u00fa visual: mapa del mundo, combate, jefe final (castillo), equipo, habilidades, fuente, y ranking. Sistema de autenticaci\u00f3n con registro personalizado que asigna una pasiva aleatoria. API REST funcional para acceder al top de jugadores, consumida por la vista de ranking. Despliegue contenedorizado con Docker y actualizaci\u00f3n autom\u00e1tica mediante GitHub Actions. El juego funciona correctamente, tiene flujo completo desde el login hasta la pantalla de victoria, y se encuentra preparado para futuras ampliaciones . \ud83d\udcda Aprendizajes y Valoraci\u00f3n \u00b6 Este proyecto ha sido un verdadero viaje de crecimiento personal y profesional. He aprendido: A modularizar correctamente la l\u00f3gica compleja. A integrar frontend y backend de forma fluida. A desplegar con herramientas modernas como Docker y GitHub Actions. A documentar cada componente del proyecto, desde el dise\u00f1o conceptual hasta la API y el despliegue. A resolver problemas reales en tiempo real, haciendo pruebas y ajustes en cada fase del desarrollo. Adem\u00e1s, este trabajo me ha ense\u00f1ado a tomar decisiones de dise\u00f1o, priorizar tareas y construir una aplicaci\u00f3n que no solo sea funcional, sino tambi\u00e9n mantenible, escalable y atractiva visualmente. \ud83c\udf89 Cierre \u00b6 Battlebound Tactics no es solo un juego: es la culminaci\u00f3n de todo lo aprendido durante mi formaci\u00f3n. Estoy orgulloso del resultado y de haber podido entregar un producto completo, divertido y t\u00e9cnicamente s\u00f3lido. Todo el trabajo \u2014desde el c\u00f3digo hasta la documentaci\u00f3n\u2014 ha sido hecho desde cero y con mucha dedicaci\u00f3n y cari\u00f1o. Muchas gracias por acompa\u00f1arme hasta el final de este viaje. \u2014 Jonatan Garc\u00eda Luna","title":"\ud83e\uddfe Conclusiones"},{"location":"conclusiones/#conclusiones-finales","text":"El desarrollo de Battlebound Tactics ha supuesto un proceso intenso, desafiante y muy gratificante, en el que he abordado de forma integral el dise\u00f1o, construcci\u00f3n, pruebas y despliegue de una aplicaci\u00f3n web que combina los principios de desarrollo backend con una experiencia visual frontend envolvente, todo ello dentro de un sistema de combate t\u00e1ctico por turnos.","title":"\u2705 Conclusiones Finales"},{"location":"conclusiones/#vision-general-del-trabajo-realizado","text":"Desde el inicio del proyecto, me propuse dise\u00f1ar un juego web completo con mec\u00e1nicas inspiradas en los RPG cl\u00e1sicos, que ofreciera al jugador una experiencia estrat\u00e9gica, envolvente y entretenida. El proyecto ha abarcado: La definici\u00f3n de una base de datos compleja con modelos como Jugador , Enemigo , Habilidad , Pasiva , Arma , Accesorio , y Combate . La creaci\u00f3n del sistema de combate por turnos m\u00e1s profundo que he desarrollado hasta la fecha, con IA enemiga, habilidades activas y pasivas, efectos de estado y estad\u00edsticas din\u00e1micas. El dise\u00f1o de una interfaz de usuario visualmente atractiva y coherente, basada en plantillas HTML, CSS personalizado y l\u00f3gica de interacci\u00f3n con JavaScript. La integraci\u00f3n de funcionalidades clave como: mapa interactivo, zonas de jefes, sistema de curaci\u00f3n, ranking de jugadores a trav\u00e9s de una API, gesti\u00f3n de equipo, habilidades, y registro/login personalizado con pasivas \u00fanicas. El uso de Docker para contenedorizaci\u00f3n y GitHub Actions para automatizar el despliegue en AWS , garantizando una entrega profesional del producto final.","title":"\ud83d\udd0d Visi\u00f3n General del Trabajo Realizado"},{"location":"conclusiones/#principales-dificultades","text":"Durante el desarrollo me enfrent\u00e9 a m\u00faltiples retos t\u00e9cnicos: L\u00f3gica compleja del combate : La cantidad de condiciones, efectos, turnos y ramificaciones del sistema de combate requiri\u00f3 un dise\u00f1o modular y cuidadoso. Resolver los efectos acumulativos, el flujo de los turnos, y la IA enemiga me exigi\u00f3 una gran precisi\u00f3n. Frontend avanzado : Aunque ten\u00eda m\u00e1s experiencia en backend, enfrentarme a interacciones complejas con JavaScript (como las animaciones del combate o las peticiones a la API) fue un desaf\u00edo que logr\u00e9 superar con investigaci\u00f3n y dedicaci\u00f3n constantes. Despliegue en AWS : El entorno gratuito de AWS present\u00f3 l\u00edmites de recursos que me obligaron a optimizar el proyecto, deshabilitando funciones no esenciales como la m\u00fasica de fondo para evitar saturar el servidor. Dise\u00f1o visual personalizado : Me propuse un dise\u00f1o muy espec\u00edfico para los mapas y pantallas, lo que implic\u00f3 muchas horas ajustando estilos CSS y capas visuales para que el resultado final fuese fiel a la idea original que ten\u00eda en mente.","title":"\u26a0\ufe0f Principales Dificultades"},{"location":"conclusiones/#evolucion-del-proyecto","text":"Si bien la planificaci\u00f3n inicial era ambiciosa, durante el desarrollo fue necesario realizar ajustes realistas. Algunas funcionalidades como el sistema de tiendas, combates PvP o inventario de objetos fueron finalmente descartadas, no por falta de capacidad, sino por una decisi\u00f3n de priorizar calidad sobre cantidad . Prefiero no incluir una funcionalidad que no est\u00e1 madura, que implementarla de forma incompleta o apresurada. Estos ajustes me permitieron centrarme en lo verdaderamente importante: un sistema de combate s\u00f3lido, una experiencia jugable clara, y una interfaz pulida. Cada modificaci\u00f3n que se hizo al plan inicial fue razonada, documentada y ejecutada con criterio.","title":"\ud83d\udcc8 Evoluci\u00f3n del Proyecto"},{"location":"conclusiones/#estado-final-del-proyecto","text":"Actualmente, Battlebound Tactics incluye: Sistema completo de combate por turnos, con IA enemiga, efectos de estado, pasivas y habilidades. Progresi\u00f3n del jugador basada en experiencia, niveles, equipo y estad\u00edsticas calculadas din\u00e1micamente durante el combate. M\u00faltiples pantallas accesibles desde un men\u00fa visual: mapa del mundo, combate, jefe final (castillo), equipo, habilidades, fuente, y ranking. Sistema de autenticaci\u00f3n con registro personalizado que asigna una pasiva aleatoria. API REST funcional para acceder al top de jugadores, consumida por la vista de ranking. Despliegue contenedorizado con Docker y actualizaci\u00f3n autom\u00e1tica mediante GitHub Actions. El juego funciona correctamente, tiene flujo completo desde el login hasta la pantalla de victoria, y se encuentra preparado para futuras ampliaciones .","title":"\u2705 Estado Final del Proyecto"},{"location":"conclusiones/#aprendizajes-y-valoracion","text":"Este proyecto ha sido un verdadero viaje de crecimiento personal y profesional. He aprendido: A modularizar correctamente la l\u00f3gica compleja. A integrar frontend y backend de forma fluida. A desplegar con herramientas modernas como Docker y GitHub Actions. A documentar cada componente del proyecto, desde el dise\u00f1o conceptual hasta la API y el despliegue. A resolver problemas reales en tiempo real, haciendo pruebas y ajustes en cada fase del desarrollo. Adem\u00e1s, este trabajo me ha ense\u00f1ado a tomar decisiones de dise\u00f1o, priorizar tareas y construir una aplicaci\u00f3n que no solo sea funcional, sino tambi\u00e9n mantenible, escalable y atractiva visualmente.","title":"\ud83d\udcda Aprendizajes y Valoraci\u00f3n"},{"location":"conclusiones/#cierre","text":"Battlebound Tactics no es solo un juego: es la culminaci\u00f3n de todo lo aprendido durante mi formaci\u00f3n. Estoy orgulloso del resultado y de haber podido entregar un producto completo, divertido y t\u00e9cnicamente s\u00f3lido. Todo el trabajo \u2014desde el c\u00f3digo hasta la documentaci\u00f3n\u2014 ha sido hecho desde cero y con mucha dedicaci\u00f3n y cari\u00f1o. Muchas gracias por acompa\u00f1arme hasta el final de este viaje. \u2014 Jonatan Garc\u00eda Luna","title":"\ud83c\udf89 Cierre"},{"location":"core-efectos/","text":"\ud83e\uddea Sistema de Efectos ( efectos.py ) \u00b6 Este m\u00f3dulo gestiona todo el sistema de efectos de estado del combate: desde los cl\u00e1sicos buffs y debuffs hasta efectos negativos como veneno o quemadura. Tambi\u00e9n maneja la aplicaci\u00f3n, mantenimiento, expiraci\u00f3n y visualizaci\u00f3n de estos efectos. Todos los efectos se almacenan en el diccionario stats_temporales[\"estados\"] , que es evaluado turno a turno para aplicar o actualizar su impacto. Este m\u00f3dulo es invocado principalmente por los m\u00f3dulos jugador.py , enemigos.py y utils_resolvedor.py . \ud83e\uddec Aplicaci\u00f3n y mantenimiento de estados \u00b6 aplicar_estado(stats_temporales, estado_nuevo) \u00b6 Aplica un nuevo efecto (buff, debuff o negativo) al conjunto de estad\u00edsticas temporales de un personaje. Evita duplicados: si un efecto similar ya existe, lo reemplaza o actualiza la duraci\u00f3n. Aplica directamente el efecto si es un buff o debuff (alterando ataque , defensa , etc.). Los efectos negativos se registran, pero se activan en procesar_estados() . procesar_estados(stats_temporales, objeto) \u00b6 Ejecuta los efectos activos: Los efectos negativos causan da\u00f1o porcentual a la salud m\u00e1xima. Los buffs y debuffs se activan si a\u00fan no lo estaban. Reduce en 1 la duraci\u00f3n de cada estado. Devuelve una lista de mensajes descriptivos para el log del combate. limpiar_estados_expirados(stats_temporales) \u00b6 Elimina efectos cuya duraci\u00f3n ha terminado y revierte sus alteraciones estad\u00edsticas. Buffs y debuffs restauran su efecto aplicado antes de ser eliminados. Los efectos expirados no se mantienen en el array de estados. \u274c Eliminaci\u00f3n de estados \u00b6 remover_estado(stats_temporales, tipo, identificador=None) \u00b6 Elimina un estado espec\u00edfico seg\u00fan tipo ( buff , debuff o negativo ) y su identificador ( stat o estado ). Si no se pasa identificador , elimina todos los estados del tipo dado. \u00datil para habilidades de purga o inmunidad. \ud83c\udf00 Aplicaci\u00f3n condicional con probabilidad \u00b6 aplicar_efecto_contrario(efecto, stats_objetivo, objetivo, log_combate=None) \u00b6 Aplica un efecto a un objetivo solo si supera una tirada de probabilidad ( tirada() ). Si falla la tirada, registra en el log que el objetivo resisti\u00f3 el efecto. Si se aplica, utiliza aplicar_estado() y a\u00f1ade una descripci\u00f3n del resultado. Este m\u00e9todo centraliza la aplicaci\u00f3n de efectos desde habilidades ofensivas o defensivas. \ud83e\uddfe Visualizaci\u00f3n e inspecci\u00f3n de efectos \u00b6 listar_estados_activos(stats_temporales) \u00b6 Devuelve una lista con descripciones legibles de todos los estados activos del personaje. Efectos negativos : muestran nombre, da\u00f1o/turno y duraci\u00f3n. Buffs y debuffs: indican stat afectado, porcentaje o valor, y duraci\u00f3n restante. estado_activo(stats_temporales, tipo, identificador) \u00b6 Comprueba si un efecto concreto est\u00e1 activo. Identifica por tipo y estado (si es negativo ) o stat (si es buff / debuff ). Devuelve True si se encuentra activo, False en caso contrario. \ud83e\udde9 Integraci\u00f3n con el sistema de combate \u00b6 Este m\u00f3dulo se utiliza en momentos clave del combate: Al aplicar efectos desde habilidades ( usar_habilidad() o usar_habilidad_enemigo() ). Al inicio de cada turno ( procesar_estados() ). Al finalizar el turno ( limpiar_estados_expirados() ). Al generar descripciones visuales ( listar_estados_activos() ). Cada efecto se maneja como un diccionario estructurado con claves como tipo , stat , valor , duracion , porcentaje y estado . \ud83e\udde0 Conclusi\u00f3n \u00b6 El m\u00f3dulo efectos.py permite una implementaci\u00f3n robusta y extensible del sistema de estados, crucial para a\u00f1adir profundidad estrat\u00e9gica al combate. Controla todo el ciclo de vida de los efectos y ofrece interfaces claras para aplicarlos, activarlos y revertirlos.","title":"Efectos"},{"location":"core-efectos/#sistema-de-efectos-efectospy","text":"Este m\u00f3dulo gestiona todo el sistema de efectos de estado del combate: desde los cl\u00e1sicos buffs y debuffs hasta efectos negativos como veneno o quemadura. Tambi\u00e9n maneja la aplicaci\u00f3n, mantenimiento, expiraci\u00f3n y visualizaci\u00f3n de estos efectos. Todos los efectos se almacenan en el diccionario stats_temporales[\"estados\"] , que es evaluado turno a turno para aplicar o actualizar su impacto. Este m\u00f3dulo es invocado principalmente por los m\u00f3dulos jugador.py , enemigos.py y utils_resolvedor.py .","title":"\ud83e\uddea Sistema de Efectos (efectos.py)"},{"location":"core-efectos/#aplicacion-y-mantenimiento-de-estados","text":"","title":"\ud83e\uddec Aplicaci\u00f3n y mantenimiento de estados"},{"location":"core-efectos/#aplicar_estadostats_temporales-estado_nuevo","text":"Aplica un nuevo efecto (buff, debuff o negativo) al conjunto de estad\u00edsticas temporales de un personaje. Evita duplicados: si un efecto similar ya existe, lo reemplaza o actualiza la duraci\u00f3n. Aplica directamente el efecto si es un buff o debuff (alterando ataque , defensa , etc.). Los efectos negativos se registran, pero se activan en procesar_estados() .","title":"aplicar_estado(stats_temporales, estado_nuevo)"},{"location":"core-efectos/#procesar_estadosstats_temporales-objeto","text":"Ejecuta los efectos activos: Los efectos negativos causan da\u00f1o porcentual a la salud m\u00e1xima. Los buffs y debuffs se activan si a\u00fan no lo estaban. Reduce en 1 la duraci\u00f3n de cada estado. Devuelve una lista de mensajes descriptivos para el log del combate.","title":"procesar_estados(stats_temporales, objeto)"},{"location":"core-efectos/#limpiar_estados_expiradosstats_temporales","text":"Elimina efectos cuya duraci\u00f3n ha terminado y revierte sus alteraciones estad\u00edsticas. Buffs y debuffs restauran su efecto aplicado antes de ser eliminados. Los efectos expirados no se mantienen en el array de estados.","title":"limpiar_estados_expirados(stats_temporales)"},{"location":"core-efectos/#eliminacion-de-estados","text":"","title":"\u274c Eliminaci\u00f3n de estados"},{"location":"core-efectos/#remover_estadostats_temporales-tipo-identificadornone","text":"Elimina un estado espec\u00edfico seg\u00fan tipo ( buff , debuff o negativo ) y su identificador ( stat o estado ). Si no se pasa identificador , elimina todos los estados del tipo dado. \u00datil para habilidades de purga o inmunidad.","title":"remover_estado(stats_temporales, tipo, identificador=None)"},{"location":"core-efectos/#aplicacion-condicional-con-probabilidad","text":"","title":"\ud83c\udf00 Aplicaci\u00f3n condicional con probabilidad"},{"location":"core-efectos/#aplicar_efecto_contrarioefecto-stats_objetivo-objetivo-log_combatenone","text":"Aplica un efecto a un objetivo solo si supera una tirada de probabilidad ( tirada() ). Si falla la tirada, registra en el log que el objetivo resisti\u00f3 el efecto. Si se aplica, utiliza aplicar_estado() y a\u00f1ade una descripci\u00f3n del resultado. Este m\u00e9todo centraliza la aplicaci\u00f3n de efectos desde habilidades ofensivas o defensivas.","title":"aplicar_efecto_contrario(efecto, stats_objetivo, objetivo, log_combate=None)"},{"location":"core-efectos/#visualizacion-e-inspeccion-de-efectos","text":"","title":"\ud83e\uddfe Visualizaci\u00f3n e inspecci\u00f3n de efectos"},{"location":"core-efectos/#listar_estados_activosstats_temporales","text":"Devuelve una lista con descripciones legibles de todos los estados activos del personaje. Efectos negativos : muestran nombre, da\u00f1o/turno y duraci\u00f3n. Buffs y debuffs: indican stat afectado, porcentaje o valor, y duraci\u00f3n restante.","title":"listar_estados_activos(stats_temporales)"},{"location":"core-efectos/#estado_activostats_temporales-tipo-identificador","text":"Comprueba si un efecto concreto est\u00e1 activo. Identifica por tipo y estado (si es negativo ) o stat (si es buff / debuff ). Devuelve True si se encuentra activo, False en caso contrario.","title":"estado_activo(stats_temporales, tipo, identificador)"},{"location":"core-efectos/#integracion-con-el-sistema-de-combate","text":"Este m\u00f3dulo se utiliza en momentos clave del combate: Al aplicar efectos desde habilidades ( usar_habilidad() o usar_habilidad_enemigo() ). Al inicio de cada turno ( procesar_estados() ). Al finalizar el turno ( limpiar_estados_expirados() ). Al generar descripciones visuales ( listar_estados_activos() ). Cada efecto se maneja como un diccionario estructurado con claves como tipo , stat , valor , duracion , porcentaje y estado .","title":"\ud83e\udde9 Integraci\u00f3n con el sistema de combate"},{"location":"core-efectos/#conclusion","text":"El m\u00f3dulo efectos.py permite una implementaci\u00f3n robusta y extensible del sistema de estados, crucial para a\u00f1adir profundidad estrat\u00e9gica al combate. Controla todo el ciclo de vida de los efectos y ofrece interfaces claras para aplicarlos, activarlos y revertirlos.","title":"\ud83e\udde0 Conclusi\u00f3n"},{"location":"core-enemigos/","text":"\ud83d\udc7e L\u00f3gica del Enemigo ( enemigos.py ) \u00b6 Este m\u00f3dulo define el comportamiento de los enemigos durante un combate. Contiene tanto la inteligencia artificial que decide sus acciones como la ejecuci\u00f3n de ataques, habilidades, efectos y cooldowns. Es el contrapunto directo del m\u00f3dulo jugador.py , y su funci\u00f3n principal ejecutar_turno_enemigo() es llamada desde la vista combate() para resolver el turno del enemigo. \u2694\ufe0f Acciones b\u00e1sicas del enemigo \u00b6 accion_basica_enemigo(stats_enemigo, enemigo, nivel_jugador) \u00b6 Realiza un ataque est\u00e1ndar del enemigo, escalado por su nivel y comparado con el del jugador. Aplica un golpe base y lo amplifica en funci\u00f3n del nivel del enemigo y el del jugador. Puede ser un golpe cr\u00edtico, lo que dobla el da\u00f1o infligido ( critico() ). Devuelve el da\u00f1o y un mensaje tem\u00e1tico. ataque_adicional_enemigo(stats_enemigo, enemigo, nivel_jugador) \u00b6 Intenta ejecutar un segundo ataque si la probabilidad lo permite ( adicional() ). Si tiene \u00e9xito, repite accion_basica_enemigo() . Si no, genera un mensaje narrativo sin infligir da\u00f1o adicional. calcular_golpe_recibido_enemigo(golpe, enemigo, stats_temporales) \u00b6 Calcula el da\u00f1o que el enemigo recibe al ser atacado por el jugador. Considera defensa y evasi\u00f3n ( esquivar() ). Establece un da\u00f1o m\u00ednimo del 1% de la salud m\u00e1xima. \ud83d\udd01 Cooldowns \u00b6 reducir_cooldowns(combate) \u00b6 Reduce en 1 todos los cooldowns activos de habilidades enemigas. Se ejecuta al inicio del turno del enemigo. Guarda los nuevos valores en la instancia Combate . cooldown_disponible(habilidad, combate) \u00b6 Verifica si una habilidad enemiga est\u00e1 lista para ser usada (cooldown en 0). aplicar_cooldown(habilidad, combate) \u00b6 Registra el cooldown de una habilidad usada, extra\u00eddo de su efecto, y lo almacena en el combate. \u2728 Uso de habilidades enemigas \u00b6 usar_habilidad_enemigo(habilidad, stats_enemigo, stats_jugador, enemigo, jugador, log) \u00b6 Ejecuta el efecto de una habilidad enemiga. Interpreta el tipo del efecto usando leer_efecto() y aplica sus consecuencias: Da\u00f1o : basado en el ataque del enemigo. Curaci\u00f3n : restauraci\u00f3n de salud en base a salud m\u00e1xima. Buff/Debuff/Negativo : genera y aplica un estado con aplicar_efecto_contrario() . Devuelve una lista de efectos ( da\u00f1o , curacion , estado ) y un mensaje para el log del combate. \ud83e\udde0 IA enemiga \u00b6 ia_enemiga(stats_enemigo, stats_jugador, habilidades_disponibles) \u00b6 Decide qu\u00e9 acci\u00f3n tomar\u00e1 el enemigo en su turno, asignando pesos a cada opci\u00f3n: Eval\u00faa salud propia y del jugador, estados activos y diferencias estad\u00edsticas. Usa evaluar_buff_o_debuff() para asignar prioridades a efectos estrat\u00e9gicos. Siempre a\u00f1ade la opci\u00f3n de ataque b\u00e1sico con peso bajo. Devuelve una elecci\u00f3n aleatoria ponderada (habilidad o \"basico\" ). evaluar_buff_o_debuff(tipo, stat_objetivo, stats_enemigo, stats_jugador) \u00b6 Asigna un peso de prioridad a buffs o debuffs dependiendo de las diferencias estad\u00edsticas entre jugador y enemigo. Si la estad\u00edstica del enemigo es inferior a la del jugador, prioriza su uso. Se usa solo internamente por ia_enemiga() . \ud83e\uddea Ejecuci\u00f3n del turno enemigo \u00b6 ejecutar_turno_enemigo(request, jugador, stats_jugador, stats_enemigo, enemigo, log, combate) \u00b6 Funci\u00f3n principal que resuelve el turno completo del enemigo. Es llamada desde la vista combate() . Inicio : reduce cooldowns con reducir_cooldowns() . Decisi\u00f3n : selecciona acci\u00f3n con ia_enemiga() . Acci\u00f3n b\u00e1sica : ejecuta accion_basica_enemigo() y posible ataque_adicional_enemigo() . Habilidad : usa usar_habilidad_enemigo() , aplica efectos, estados y cooldowns. Al final del turno, comprueba si el jugador ha sido derrotado y llama a resolver_derrota() si procede. \ud83e\udde9 Relaci\u00f3n con la vista combate() \u00b6 La vista combate() invoca ejecutar_turno_enemigo() para resolver la respuesta del enemigo Fragmento en views.py : \u00b6 resultado = ejecutar_turno_enemigo(request, jugador, stats_jugador, stats_enemigo, enemigo, log, combate) \u00b6 Esto asegura que cada combate siga una secuencia completa: jugador \u2192 enemigo (o enemigo \u2192 jugador, si el enemigo es m\u00e1s r\u00e1pido). \ud83e\udde0 Conclusi\u00f3n \u00b6 El m\u00f3dulo enemigos.py representa la inteligencia y ejecuci\u00f3n de la l\u00f3gica de los enemigos. Controla sus decisiones, gestiona sus habilidades y permite una respuesta din\u00e1mica y estrat\u00e9gica dentro del sistema de combate. Su dise\u00f1o modular permite una IA flexible y adaptativa en funci\u00f3n del contexto del combate.","title":"Enemigos"},{"location":"core-enemigos/#logica-del-enemigo-enemigospy","text":"Este m\u00f3dulo define el comportamiento de los enemigos durante un combate. Contiene tanto la inteligencia artificial que decide sus acciones como la ejecuci\u00f3n de ataques, habilidades, efectos y cooldowns. Es el contrapunto directo del m\u00f3dulo jugador.py , y su funci\u00f3n principal ejecutar_turno_enemigo() es llamada desde la vista combate() para resolver el turno del enemigo.","title":"\ud83d\udc7e L\u00f3gica del Enemigo (enemigos.py)"},{"location":"core-enemigos/#acciones-basicas-del-enemigo","text":"","title":"\u2694\ufe0f Acciones b\u00e1sicas del enemigo"},{"location":"core-enemigos/#accion_basica_enemigostats_enemigo-enemigo-nivel_jugador","text":"Realiza un ataque est\u00e1ndar del enemigo, escalado por su nivel y comparado con el del jugador. Aplica un golpe base y lo amplifica en funci\u00f3n del nivel del enemigo y el del jugador. Puede ser un golpe cr\u00edtico, lo que dobla el da\u00f1o infligido ( critico() ). Devuelve el da\u00f1o y un mensaje tem\u00e1tico.","title":"accion_basica_enemigo(stats_enemigo, enemigo, nivel_jugador)"},{"location":"core-enemigos/#ataque_adicional_enemigostats_enemigo-enemigo-nivel_jugador","text":"Intenta ejecutar un segundo ataque si la probabilidad lo permite ( adicional() ). Si tiene \u00e9xito, repite accion_basica_enemigo() . Si no, genera un mensaje narrativo sin infligir da\u00f1o adicional.","title":"ataque_adicional_enemigo(stats_enemigo, enemigo, nivel_jugador)"},{"location":"core-enemigos/#calcular_golpe_recibido_enemigogolpe-enemigo-stats_temporales","text":"Calcula el da\u00f1o que el enemigo recibe al ser atacado por el jugador. Considera defensa y evasi\u00f3n ( esquivar() ). Establece un da\u00f1o m\u00ednimo del 1% de la salud m\u00e1xima.","title":"calcular_golpe_recibido_enemigo(golpe, enemigo, stats_temporales)"},{"location":"core-enemigos/#cooldowns","text":"","title":"\ud83d\udd01 Cooldowns"},{"location":"core-enemigos/#reducir_cooldownscombate","text":"Reduce en 1 todos los cooldowns activos de habilidades enemigas. Se ejecuta al inicio del turno del enemigo. Guarda los nuevos valores en la instancia Combate .","title":"reducir_cooldowns(combate)"},{"location":"core-enemigos/#cooldown_disponiblehabilidad-combate","text":"Verifica si una habilidad enemiga est\u00e1 lista para ser usada (cooldown en 0).","title":"cooldown_disponible(habilidad, combate)"},{"location":"core-enemigos/#aplicar_cooldownhabilidad-combate","text":"Registra el cooldown de una habilidad usada, extra\u00eddo de su efecto, y lo almacena en el combate.","title":"aplicar_cooldown(habilidad, combate)"},{"location":"core-enemigos/#uso-de-habilidades-enemigas","text":"","title":"\u2728 Uso de habilidades enemigas"},{"location":"core-enemigos/#usar_habilidad_enemigohabilidad-stats_enemigo-stats_jugador-enemigo-jugador-log","text":"Ejecuta el efecto de una habilidad enemiga. Interpreta el tipo del efecto usando leer_efecto() y aplica sus consecuencias: Da\u00f1o : basado en el ataque del enemigo. Curaci\u00f3n : restauraci\u00f3n de salud en base a salud m\u00e1xima. Buff/Debuff/Negativo : genera y aplica un estado con aplicar_efecto_contrario() . Devuelve una lista de efectos ( da\u00f1o , curacion , estado ) y un mensaje para el log del combate.","title":"usar_habilidad_enemigo(habilidad, stats_enemigo, stats_jugador, enemigo, jugador, log)"},{"location":"core-enemigos/#ia-enemiga","text":"","title":"\ud83e\udde0 IA enemiga"},{"location":"core-enemigos/#ia_enemigastats_enemigo-stats_jugador-habilidades_disponibles","text":"Decide qu\u00e9 acci\u00f3n tomar\u00e1 el enemigo en su turno, asignando pesos a cada opci\u00f3n: Eval\u00faa salud propia y del jugador, estados activos y diferencias estad\u00edsticas. Usa evaluar_buff_o_debuff() para asignar prioridades a efectos estrat\u00e9gicos. Siempre a\u00f1ade la opci\u00f3n de ataque b\u00e1sico con peso bajo. Devuelve una elecci\u00f3n aleatoria ponderada (habilidad o \"basico\" ).","title":"ia_enemiga(stats_enemigo, stats_jugador, habilidades_disponibles)"},{"location":"core-enemigos/#evaluar_buff_o_debufftipo-stat_objetivo-stats_enemigo-stats_jugador","text":"Asigna un peso de prioridad a buffs o debuffs dependiendo de las diferencias estad\u00edsticas entre jugador y enemigo. Si la estad\u00edstica del enemigo es inferior a la del jugador, prioriza su uso. Se usa solo internamente por ia_enemiga() .","title":"evaluar_buff_o_debuff(tipo, stat_objetivo, stats_enemigo, stats_jugador)"},{"location":"core-enemigos/#ejecucion-del-turno-enemigo","text":"","title":"\ud83e\uddea Ejecuci\u00f3n del turno enemigo"},{"location":"core-enemigos/#ejecutar_turno_enemigorequest-jugador-stats_jugador-stats_enemigo-enemigo-log-combate","text":"Funci\u00f3n principal que resuelve el turno completo del enemigo. Es llamada desde la vista combate() . Inicio : reduce cooldowns con reducir_cooldowns() . Decisi\u00f3n : selecciona acci\u00f3n con ia_enemiga() . Acci\u00f3n b\u00e1sica : ejecuta accion_basica_enemigo() y posible ataque_adicional_enemigo() . Habilidad : usa usar_habilidad_enemigo() , aplica efectos, estados y cooldowns. Al final del turno, comprueba si el jugador ha sido derrotado y llama a resolver_derrota() si procede.","title":"ejecutar_turno_enemigo(request, jugador, stats_jugador, stats_enemigo, enemigo, log, combate)"},{"location":"core-enemigos/#relacion-con-la-vista-combate","text":"La vista combate() invoca ejecutar_turno_enemigo() para resolver la respuesta del enemigo","title":"\ud83e\udde9 Relaci\u00f3n con la vista combate()"},{"location":"core-enemigos/#fragmento-en-viewspy","text":"","title":"Fragmento en views.py:"},{"location":"core-enemigos/#resultado-ejecutar_turno_enemigorequest-jugador-stats_jugador-stats_enemigo-enemigo-log-combate","text":"Esto asegura que cada combate siga una secuencia completa: jugador \u2192 enemigo (o enemigo \u2192 jugador, si el enemigo es m\u00e1s r\u00e1pido).","title":"resultado = ejecutar_turno_enemigo(request, jugador, stats_jugador, stats_enemigo, enemigo, log, combate)"},{"location":"core-enemigos/#conclusion","text":"El m\u00f3dulo enemigos.py representa la inteligencia y ejecuci\u00f3n de la l\u00f3gica de los enemigos. Controla sus decisiones, gestiona sus habilidades y permite una respuesta din\u00e1mica y estrat\u00e9gica dentro del sistema de combate. Su dise\u00f1o modular permite una IA flexible y adaptativa en funci\u00f3n del contexto del combate.","title":"\ud83e\udde0 Conclusi\u00f3n"},{"location":"core-estadisticas/","text":"\ud83d\udcca Estad\u00edsticas de Combate ( estadisticas.py ) \u00b6 Este m\u00f3dulo centraliza el c\u00e1lculo de las estad\u00edsticas del jugador y los enemigos en combate. Se encarga de combinar los valores base con bonificaciones por pasiva, equipamiento y otros factores contextuales para producir los valores temporales que se usan en cada turno. Tambi\u00e9n ofrece utilidades para ajustar salud y energ\u00eda, mantener la proporci\u00f3n de estado entre combates, y generar pasivas aleatorias al registrar un nuevo jugador. \ud83e\uddf1 Inicializaci\u00f3n de estad\u00edsticas \u00b6 inicializar_stats(objeto) \u00b6 Obtiene las estad\u00edsticas base de un objeto (jugador o enemigo): salud_max , salud , ataque , defensa , velocidad Si el objeto tiene energ\u00eda espiritual ( jugador ), a\u00f1ade tambi\u00e9n energia_max y energia Este es el punto de partida de todos los c\u00e1lculos estad\u00edsticos posteriores. \ud83e\uddec Bonificadores de pasiva \u00b6 aplicar_pasiva(jugador, stats) \u00b6 Aplica los efectos de la habilidad pasiva del jugador sobre las estad\u00edsticas base. Extrae el diccionario efecto de la instancia Pasiva Aumenta salud_max , energia_max , ataque , defensa y velocidad seg\u00fan porcentajes definidos en la pasiva Este paso ocurre \u00fanicamente si el jugador tiene asignada una habilidad pasiva, que por defecto siempre la tiene. \ud83d\udee1\ufe0f Bonificadores de equipo \u00b6 aplicar_equipo(jugador, stats) \u00b6 Aplica los modificadores que otorgan el arma y el accesorio del jugador. Aumenta o disminuye directamente estad\u00edsticas como ataque , defensa , velocidad Si el accesorio lo permite, a\u00f1ade o resta salud y energ\u00eda espiritual \ud83e\uddee Composici\u00f3n total de estad\u00edsticas \u00b6 calcular_stats_totales(objeto) \u00b6 Realiza la suma total de estad\u00edsticas base + pasiva + equipo. Internamente llama a inicializar_stats() , aplicar_pasiva() y aplicar_equipo() si aplican. Funciona tanto para jugadores como enemigos (detecta si el objeto tiene habilidad_pasiva o arma ). \ud83d\udd27 Ajustes proporcionales \u00b6 ajuste_stats(objeto, stats) \u00b6 Recalcula la salud y energ\u00eda actuales para ajustarlo a sus estad\u00edsticas base. Usa porcentajes para escalar correctamente los nuevos valores. Asegura que la salud y energ\u00eda no se regeneren ni pierdan tras un cambio de stats. \u2699\ufe0f Wrapper principal \u00b6 obtener_stats_temporales(objeto) \u00b6 Funci\u00f3n clave que se invoca desde la vista combate para obtener las estad\u00edsticas actuales de un jugador o enemigo. Llama a calcular_stats_totales() y luego a ajuste_stats() . Devuelve un diccionario listo para usar en combate, con todos los campos relevantes. Este m\u00e9todo se usa justo antes de procesar un turno o acci\u00f3n, asegurando que se emplean las estad\u00edsticas m\u00e1s precisas. \ud83c\udfb2 Pasiva aleatoria al registrarse \u00b6 generar_pasiva_aleatoria_jugador(jugador) \u00b6 Genera una instancia de Pasiva \u00fanica al registrar un nuevo jugador. Asigna valores aleatorios entre 0.0 y 1.0 a todos los campos de efecto Crea el objeto Pasiva en la base de datos Se asocia autom\u00e1ticamente al jugador Este m\u00e9todo garantiza que cada jugador inicia con una combinaci\u00f3n pasiva \u00fanica. \ud83e\udde9 Relaci\u00f3n con otros m\u00f3dulos \u00b6 Este m\u00f3dulo es utilizado constantemente por: jugador.py y enemigos.py , para obtener estad\u00edsticas en combate. views.py , cuando se prepara el contexto de combate o se inicia una nueva sesi\u00f3n. models.py , al registrar jugadores y asignar pasivas. Las estad\u00edsticas generadas son claves para que los efectos, habilidades, y da\u00f1os funcionen correctamente. \ud83e\udde0 Conclusi\u00f3n \u00b6 El m\u00f3dulo estadisticas.py act\u00faa como el n\u00facleo de c\u00e1lculo para todo lo relacionado con los atributos en combate. Su dise\u00f1o flexible permite extender f\u00e1cilmente los modificadores, integrar nuevos tipos de pasivas o equipo, y mantener la coherencia entre diferentes entidades del juego.","title":"Estad\u00edsticas"},{"location":"core-estadisticas/#estadisticas-de-combate-estadisticaspy","text":"Este m\u00f3dulo centraliza el c\u00e1lculo de las estad\u00edsticas del jugador y los enemigos en combate. Se encarga de combinar los valores base con bonificaciones por pasiva, equipamiento y otros factores contextuales para producir los valores temporales que se usan en cada turno. Tambi\u00e9n ofrece utilidades para ajustar salud y energ\u00eda, mantener la proporci\u00f3n de estado entre combates, y generar pasivas aleatorias al registrar un nuevo jugador.","title":"\ud83d\udcca Estad\u00edsticas de Combate (estadisticas.py)"},{"location":"core-estadisticas/#inicializacion-de-estadisticas","text":"","title":"\ud83e\uddf1 Inicializaci\u00f3n de estad\u00edsticas"},{"location":"core-estadisticas/#inicializar_statsobjeto","text":"Obtiene las estad\u00edsticas base de un objeto (jugador o enemigo): salud_max , salud , ataque , defensa , velocidad Si el objeto tiene energ\u00eda espiritual ( jugador ), a\u00f1ade tambi\u00e9n energia_max y energia Este es el punto de partida de todos los c\u00e1lculos estad\u00edsticos posteriores.","title":"inicializar_stats(objeto)"},{"location":"core-estadisticas/#bonificadores-de-pasiva","text":"","title":"\ud83e\uddec Bonificadores de pasiva"},{"location":"core-estadisticas/#aplicar_pasivajugador-stats","text":"Aplica los efectos de la habilidad pasiva del jugador sobre las estad\u00edsticas base. Extrae el diccionario efecto de la instancia Pasiva Aumenta salud_max , energia_max , ataque , defensa y velocidad seg\u00fan porcentajes definidos en la pasiva Este paso ocurre \u00fanicamente si el jugador tiene asignada una habilidad pasiva, que por defecto siempre la tiene.","title":"aplicar_pasiva(jugador, stats)"},{"location":"core-estadisticas/#bonificadores-de-equipo","text":"","title":"\ud83d\udee1\ufe0f Bonificadores de equipo"},{"location":"core-estadisticas/#aplicar_equipojugador-stats","text":"Aplica los modificadores que otorgan el arma y el accesorio del jugador. Aumenta o disminuye directamente estad\u00edsticas como ataque , defensa , velocidad Si el accesorio lo permite, a\u00f1ade o resta salud y energ\u00eda espiritual","title":"aplicar_equipo(jugador, stats)"},{"location":"core-estadisticas/#composicion-total-de-estadisticas","text":"","title":"\ud83e\uddee Composici\u00f3n total de estad\u00edsticas"},{"location":"core-estadisticas/#calcular_stats_totalesobjeto","text":"Realiza la suma total de estad\u00edsticas base + pasiva + equipo. Internamente llama a inicializar_stats() , aplicar_pasiva() y aplicar_equipo() si aplican. Funciona tanto para jugadores como enemigos (detecta si el objeto tiene habilidad_pasiva o arma ).","title":"calcular_stats_totales(objeto)"},{"location":"core-estadisticas/#ajustes-proporcionales","text":"","title":"\ud83d\udd27 Ajustes proporcionales"},{"location":"core-estadisticas/#ajuste_statsobjeto-stats","text":"Recalcula la salud y energ\u00eda actuales para ajustarlo a sus estad\u00edsticas base. Usa porcentajes para escalar correctamente los nuevos valores. Asegura que la salud y energ\u00eda no se regeneren ni pierdan tras un cambio de stats.","title":"ajuste_stats(objeto, stats)"},{"location":"core-estadisticas/#wrapper-principal","text":"","title":"\u2699\ufe0f Wrapper principal"},{"location":"core-estadisticas/#obtener_stats_temporalesobjeto","text":"Funci\u00f3n clave que se invoca desde la vista combate para obtener las estad\u00edsticas actuales de un jugador o enemigo. Llama a calcular_stats_totales() y luego a ajuste_stats() . Devuelve un diccionario listo para usar en combate, con todos los campos relevantes. Este m\u00e9todo se usa justo antes de procesar un turno o acci\u00f3n, asegurando que se emplean las estad\u00edsticas m\u00e1s precisas.","title":"obtener_stats_temporales(objeto)"},{"location":"core-estadisticas/#pasiva-aleatoria-al-registrarse","text":"","title":"\ud83c\udfb2 Pasiva aleatoria al registrarse"},{"location":"core-estadisticas/#generar_pasiva_aleatoria_jugadorjugador","text":"Genera una instancia de Pasiva \u00fanica al registrar un nuevo jugador. Asigna valores aleatorios entre 0.0 y 1.0 a todos los campos de efecto Crea el objeto Pasiva en la base de datos Se asocia autom\u00e1ticamente al jugador Este m\u00e9todo garantiza que cada jugador inicia con una combinaci\u00f3n pasiva \u00fanica.","title":"generar_pasiva_aleatoria_jugador(jugador)"},{"location":"core-estadisticas/#relacion-con-otros-modulos","text":"Este m\u00f3dulo es utilizado constantemente por: jugador.py y enemigos.py , para obtener estad\u00edsticas en combate. views.py , cuando se prepara el contexto de combate o se inicia una nueva sesi\u00f3n. models.py , al registrar jugadores y asignar pasivas. Las estad\u00edsticas generadas son claves para que los efectos, habilidades, y da\u00f1os funcionen correctamente.","title":"\ud83e\udde9 Relaci\u00f3n con otros m\u00f3dulos"},{"location":"core-estadisticas/#conclusion","text":"El m\u00f3dulo estadisticas.py act\u00faa como el n\u00facleo de c\u00e1lculo para todo lo relacionado con los atributos en combate. Su dise\u00f1o flexible permite extender f\u00e1cilmente los modificadores, integrar nuevos tipos de pasivas o equipo, y mantener la coherencia entre diferentes entidades del juego.","title":"\ud83e\udde0 Conclusi\u00f3n"},{"location":"core-jugador/","text":"\ud83e\uddd9\u200d\u2642\ufe0f L\u00f3gica del Jugador ( jugador.py ) \u00b6 Este m\u00f3dulo contiene la l\u00f3gica fundamental del jugador durante el combate. Define c\u00f3mo el jugador ataca, utiliza habilidades, recibe da\u00f1o, sube de nivel, gana experiencia y ejecuta su turno. Es llamado directamente desde la vista combate() a trav\u00e9s de la funci\u00f3n ejecutar_turno_jugador() , lo que lo convierte en una pieza central del sistema. \u2694\ufe0f Acciones b\u00e1sicas del combate \u00b6 accion_basica(stats_temporales, jugador) \u00b6 Realiza un ataque b\u00e1sico. Calcula el da\u00f1o infligido, incluyendo si se trata de un golpe cr\u00edtico. Si hay cr\u00edtico (probabilidad determinada por critico() ), el da\u00f1o se multiplica por 2.5. Devuelve el da\u00f1o infligido y un mensaje para el registro del combate. ataque_adicional(stats, jugador) \u00b6 Intenta realizar un segundo ataque en el mismo turno si se cumple la probabilidad ( adicional() ). Si se activa, llama a accion_basica() y lo ejecuta de nuevo. Si no, devuelve un mensaje indicando que no fue posible continuar la ofensiva. calcular_golpe_recibido(golpe, jugador, stats_temporales) \u00b6 Calcula el da\u00f1o que recibe el jugador, teniendo en cuenta su defensa y probabilidad de esquivar ( probabilidades.esquivar() ). Si esquiva, el da\u00f1o es 0. Si no, el da\u00f1o se reduce por defensa y se garantiza un m\u00ednimo del 0.125% de la salud m\u00e1xima. \u2728 Uso de habilidades \u00b6 uso_habilidad(jugador, habilidad, stats_temporales) \u00b6 L\u00f3gica para el uso de habilidades activas (habilidad_1, 2 o 3). Verifica si el jugador tiene energ\u00eda y salud suficiente para ejecutar la habilidad. Aplica el coste correspondiente. Interpreta el efecto (da\u00f1o, curaci\u00f3n, buff, debuff) usando leer_efecto() y aplicar_estado() . Devuelve los efectos generados y los mensajes a mostrar en el log del combate. \ud83e\uddee C\u00e1lculos post-combate \u00b6 actualizar_stats_finales(jugador, stats_temporales) \u00b6 Actualiza la salud y energ\u00eda reales del jugador despu\u00e9s del combate. Calcula los porcentajes restantes de salud y energ\u00eda. Los aplica sobre los valores m\u00e1ximos del jugador para guardarlos en la base de datos. \ud83d\udcc8 Progresi\u00f3n y experiencia \u00b6 subir_nivel(jugador, nuevo_nivel) \u00b6 Incrementa el nivel del jugador y escala sus estad\u00edsticas seg\u00fan su clase. Aplica una curva base y un multiplicador por nivel y clase. Aumenta salud m\u00e1xima, energ\u00eda espiritual, ataque, defensa y velocidad. obtener_incremento_exp_por_nivel(nivel) \u00b6 Devuelve el porcentaje de incremento de la experiencia m\u00e1xima por nivel seg\u00fan el rango de niveles: 0.05 hasta nivel 25 0.08 hasta nivel 50 0.12 hasta nivel 80 0.15 hasta nivel 120 0.20 a partir de ah\u00ed ganar_experiencia(jugador, exp_ganada) \u00b6 A\u00f1ade experiencia al jugador y maneja las subidas de nivel si se supera el m\u00e1ximo. Utiliza subir_nivel() y obtener_incremento_exp_por_nivel() . Devuelve un log con mensajes de experiencia ganada y niveles alcanzados. \ud83d\udd01 Ejecuci\u00f3n del turno del jugador \u00b6 ejecutar_turno_jugador(request, jugador, combate, stats_jugador, stats_enemigo, enemigo, accion, log) \u00b6 Esta funci\u00f3n es llamada desde la vista combate() cuando el jugador realiza una acci\u00f3n. \"atacar\" : Ejecuta accion_basica() , aplica el da\u00f1o al enemigo, y ,si se activa, realiza un ataque_adicional() . \"habilidad_1\", \"habilidad_2\", \"habilidad_3\" : Llama a uso_habilidad() y procesa sus efectos. \"huir\" : Termina el combate como derrota para el jugador con resolver_derrota() . \"pasar\" : El jugador no act\u00faa y recupera un peque\u00f1o porcentaje de salud. Todos los efectos se anotan en el log , y se comprueba si el enemigo ha sido derrotado para llamar a resolver_victoria() . \ud83e\udde9 Relaci\u00f3n con la vista combate() \u00b6 La funci\u00f3n ejecutar_turno_jugador() es invocada directamente en la vista combate() cuando el jugador env\u00eda un POST con una acci\u00f3n. Es el punto de entrada de toda interacci\u00f3n del jugador en combate y delega internamente en el resto de funciones del m\u00f3dulo. Fragmento relevante en views.py : \u00b6 resultado = ejecutar_turno_jugador(request, jugador, combate, stats_jugador, stats_enemigo, enemigo, accion, log) \u00b6 \ud83e\udde0 Conclusi\u00f3n \u00b6 Este m\u00f3dulo representa el comportamiento completo del jugador en combate. Desde sus ataques b\u00e1sicos y habilidades hasta su evoluci\u00f3n y progresi\u00f3n por niveles. Todas las funciones est\u00e1n integradas en la vista de combate y definen la experiencia jugable del jugador desde el punto de vista de la l\u00f3gica del servidor.","title":"Jugador"},{"location":"core-jugador/#logica-del-jugador-jugadorpy","text":"Este m\u00f3dulo contiene la l\u00f3gica fundamental del jugador durante el combate. Define c\u00f3mo el jugador ataca, utiliza habilidades, recibe da\u00f1o, sube de nivel, gana experiencia y ejecuta su turno. Es llamado directamente desde la vista combate() a trav\u00e9s de la funci\u00f3n ejecutar_turno_jugador() , lo que lo convierte en una pieza central del sistema.","title":"\ud83e\uddd9\u200d\u2642\ufe0f L\u00f3gica del Jugador (jugador.py)"},{"location":"core-jugador/#acciones-basicas-del-combate","text":"","title":"\u2694\ufe0f Acciones b\u00e1sicas del combate"},{"location":"core-jugador/#accion_basicastats_temporales-jugador","text":"Realiza un ataque b\u00e1sico. Calcula el da\u00f1o infligido, incluyendo si se trata de un golpe cr\u00edtico. Si hay cr\u00edtico (probabilidad determinada por critico() ), el da\u00f1o se multiplica por 2.5. Devuelve el da\u00f1o infligido y un mensaje para el registro del combate.","title":"accion_basica(stats_temporales, jugador)"},{"location":"core-jugador/#ataque_adicionalstats-jugador","text":"Intenta realizar un segundo ataque en el mismo turno si se cumple la probabilidad ( adicional() ). Si se activa, llama a accion_basica() y lo ejecuta de nuevo. Si no, devuelve un mensaje indicando que no fue posible continuar la ofensiva.","title":"ataque_adicional(stats, jugador)"},{"location":"core-jugador/#calcular_golpe_recibidogolpe-jugador-stats_temporales","text":"Calcula el da\u00f1o que recibe el jugador, teniendo en cuenta su defensa y probabilidad de esquivar ( probabilidades.esquivar() ). Si esquiva, el da\u00f1o es 0. Si no, el da\u00f1o se reduce por defensa y se garantiza un m\u00ednimo del 0.125% de la salud m\u00e1xima.","title":"calcular_golpe_recibido(golpe, jugador, stats_temporales)"},{"location":"core-jugador/#uso-de-habilidades","text":"","title":"\u2728 Uso de habilidades"},{"location":"core-jugador/#uso_habilidadjugador-habilidad-stats_temporales","text":"L\u00f3gica para el uso de habilidades activas (habilidad_1, 2 o 3). Verifica si el jugador tiene energ\u00eda y salud suficiente para ejecutar la habilidad. Aplica el coste correspondiente. Interpreta el efecto (da\u00f1o, curaci\u00f3n, buff, debuff) usando leer_efecto() y aplicar_estado() . Devuelve los efectos generados y los mensajes a mostrar en el log del combate.","title":"uso_habilidad(jugador, habilidad, stats_temporales)"},{"location":"core-jugador/#calculos-post-combate","text":"","title":"\ud83e\uddee C\u00e1lculos post-combate"},{"location":"core-jugador/#actualizar_stats_finalesjugador-stats_temporales","text":"Actualiza la salud y energ\u00eda reales del jugador despu\u00e9s del combate. Calcula los porcentajes restantes de salud y energ\u00eda. Los aplica sobre los valores m\u00e1ximos del jugador para guardarlos en la base de datos.","title":"actualizar_stats_finales(jugador, stats_temporales)"},{"location":"core-jugador/#progresion-y-experiencia","text":"","title":"\ud83d\udcc8 Progresi\u00f3n y experiencia"},{"location":"core-jugador/#subir_niveljugador-nuevo_nivel","text":"Incrementa el nivel del jugador y escala sus estad\u00edsticas seg\u00fan su clase. Aplica una curva base y un multiplicador por nivel y clase. Aumenta salud m\u00e1xima, energ\u00eda espiritual, ataque, defensa y velocidad.","title":"subir_nivel(jugador, nuevo_nivel)"},{"location":"core-jugador/#obtener_incremento_exp_por_nivelnivel","text":"Devuelve el porcentaje de incremento de la experiencia m\u00e1xima por nivel seg\u00fan el rango de niveles: 0.05 hasta nivel 25 0.08 hasta nivel 50 0.12 hasta nivel 80 0.15 hasta nivel 120 0.20 a partir de ah\u00ed","title":"obtener_incremento_exp_por_nivel(nivel)"},{"location":"core-jugador/#ganar_experienciajugador-exp_ganada","text":"A\u00f1ade experiencia al jugador y maneja las subidas de nivel si se supera el m\u00e1ximo. Utiliza subir_nivel() y obtener_incremento_exp_por_nivel() . Devuelve un log con mensajes de experiencia ganada y niveles alcanzados.","title":"ganar_experiencia(jugador, exp_ganada)"},{"location":"core-jugador/#ejecucion-del-turno-del-jugador","text":"","title":"\ud83d\udd01 Ejecuci\u00f3n del turno del jugador"},{"location":"core-jugador/#ejecutar_turno_jugadorrequest-jugador-combate-stats_jugador-stats_enemigo-enemigo-accion-log","text":"Esta funci\u00f3n es llamada desde la vista combate() cuando el jugador realiza una acci\u00f3n. \"atacar\" : Ejecuta accion_basica() , aplica el da\u00f1o al enemigo, y ,si se activa, realiza un ataque_adicional() . \"habilidad_1\", \"habilidad_2\", \"habilidad_3\" : Llama a uso_habilidad() y procesa sus efectos. \"huir\" : Termina el combate como derrota para el jugador con resolver_derrota() . \"pasar\" : El jugador no act\u00faa y recupera un peque\u00f1o porcentaje de salud. Todos los efectos se anotan en el log , y se comprueba si el enemigo ha sido derrotado para llamar a resolver_victoria() .","title":"ejecutar_turno_jugador(request, jugador, combate, stats_jugador, stats_enemigo, enemigo, accion, log)"},{"location":"core-jugador/#relacion-con-la-vista-combate","text":"La funci\u00f3n ejecutar_turno_jugador() es invocada directamente en la vista combate() cuando el jugador env\u00eda un POST con una acci\u00f3n. Es el punto de entrada de toda interacci\u00f3n del jugador en combate y delega internamente en el resto de funciones del m\u00f3dulo.","title":"\ud83e\udde9 Relaci\u00f3n con la vista combate()"},{"location":"core-jugador/#fragmento-relevante-en-viewspy","text":"","title":"Fragmento relevante en views.py:"},{"location":"core-jugador/#resultado-ejecutar_turno_jugadorrequest-jugador-combate-stats_jugador-stats_enemigo-enemigo-accion-log","text":"","title":"resultado = ejecutar_turno_jugador(request, jugador, combate, stats_jugador, stats_enemigo, enemigo, accion, log)"},{"location":"core-jugador/#conclusion","text":"Este m\u00f3dulo representa el comportamiento completo del jugador en combate. Desde sus ataques b\u00e1sicos y habilidades hasta su evoluci\u00f3n y progresi\u00f3n por niveles. Todas las funciones est\u00e1n integradas en la vista de combate y definen la experiencia jugable del jugador desde el punto de vista de la l\u00f3gica del servidor.","title":"\ud83e\udde0 Conclusi\u00f3n"},{"location":"core-probabilidades/","text":"\ud83c\udfb2 Sistema de Probabilidades ( probabilidades.py ) \u00b6 Este m\u00f3dulo define todas las probabilidades que intervienen en el combate: golpes cr\u00edticos, esquivas y ataques adicionales. Permite encapsular la l\u00f3gica de azar dentro de funciones claras y reutilizables, ajustadas al tipo de clase del jugador (el enemigo tiene unos porcentajes predefinidos). Su prop\u00f3sito es centralizar la aleatoriedad y personalizarla seg\u00fan la clase de cada combatiente, garantizando coherencia y balance. \ud83e\uddea Tirada base \u00b6 tirada(probabilidad) \u00b6 Realiza una tirada aleatoria seg\u00fan un valor entre 0.0 y 1.0. Usa random() para generar un n\u00famero aleatorio. Devuelve True si el resultado cae dentro de la probabilidad pasada como par\u00e1metro. Internamente utilizada por todas las funciones de este m\u00f3dulo. \ud83d\udcca Tabla de probabilidades por clase \u00b6 obtener_probabilidades_por_clase(clase) \u00b6 Devuelve un diccionario con las probabilidades correspondientes a una clase: critico : probabilidad de golpe cr\u00edtico esquivar : probabilidad de evadir un ataque adicional : probabilidad de realizar un ataque extra Clases definidas y sus valores: \u00b6 Clase Cr\u00edtico Esquivar Adicional GUERRERO 0.15 0.04 0.10 ARQUERO 0.22 0.18 0.22 MAGO 0.17 0.05 0.12 LUCHADOR 0.16 0.07 0.14 ESPIRITUALISTA 0.18 0.09 0.13 ASTRAL 0.20 0.10 0.18 Si se pasa una clase desconocida (o un enemigo), se devuelve un conjunto de probabilidades neutras por defecto ( 0.10 en cada categor\u00eda). \u2694\ufe0f Probabilidades de combate \u00b6 critico(objetivo) \u00b6 Determina si el ataque del objetivo resulta en un golpe cr\u00edtico. Extrae la clase del objetivo , obtiene su probabilidad correspondiente y ejecuta una tirada() . Devuelve True si se produce un cr\u00edtico, False en caso contrario. esquivar(objetivo) \u00b6 Determina si el objetivo logra esquivar un ataque recibido. Funciona igual que critico() , pero evaluando la probabilidad de esquiva. adicional(objetivo) \u00b6 Determina si el objetivo realiza un segundo ataque en el mismo turno. Se usa com\u00fanmente tras realizar un accion_basica() para verificar si se repite el ataque. \ud83e\udde9 Relaci\u00f3n con otros m\u00f3dulos \u00b6 El m\u00f3dulo probabilidades.py es utilizado directamente en: jugador.py y enemigos.py , durante las funciones accion_basica() , ataque_adicional() y c\u00e1lculo de calcular_golpe_recibido() efectos.py , en aplicar_efecto_contrario() para verificar si un efecto logra aplicarse Su dise\u00f1o garantiza consistencia entre las clases y sus atributos probabil\u00edsticos, generando una experiencia de combate variada y equilibrada. \ud83e\udde0 Conclusi\u00f3n \u00b6 El m\u00f3dulo probabilidades.py encapsula la l\u00f3gica de azar en el combate, permitiendo controlar con claridad qu\u00e9 tan probable es un efecto en funci\u00f3n de la clase del personaje. Es sencillo, reutilizable y act\u00faa como base para un sistema de combate din\u00e1mico y estrat\u00e9gico.","title":"Probabilidades"},{"location":"core-probabilidades/#sistema-de-probabilidades-probabilidadespy","text":"Este m\u00f3dulo define todas las probabilidades que intervienen en el combate: golpes cr\u00edticos, esquivas y ataques adicionales. Permite encapsular la l\u00f3gica de azar dentro de funciones claras y reutilizables, ajustadas al tipo de clase del jugador (el enemigo tiene unos porcentajes predefinidos). Su prop\u00f3sito es centralizar la aleatoriedad y personalizarla seg\u00fan la clase de cada combatiente, garantizando coherencia y balance.","title":"\ud83c\udfb2 Sistema de Probabilidades (probabilidades.py)"},{"location":"core-probabilidades/#tirada-base","text":"","title":"\ud83e\uddea Tirada base"},{"location":"core-probabilidades/#tiradaprobabilidad","text":"Realiza una tirada aleatoria seg\u00fan un valor entre 0.0 y 1.0. Usa random() para generar un n\u00famero aleatorio. Devuelve True si el resultado cae dentro de la probabilidad pasada como par\u00e1metro. Internamente utilizada por todas las funciones de este m\u00f3dulo.","title":"tirada(probabilidad)"},{"location":"core-probabilidades/#tabla-de-probabilidades-por-clase","text":"","title":"\ud83d\udcca Tabla de probabilidades por clase"},{"location":"core-probabilidades/#obtener_probabilidades_por_claseclase","text":"Devuelve un diccionario con las probabilidades correspondientes a una clase: critico : probabilidad de golpe cr\u00edtico esquivar : probabilidad de evadir un ataque adicional : probabilidad de realizar un ataque extra","title":"obtener_probabilidades_por_clase(clase)"},{"location":"core-probabilidades/#clases-definidas-y-sus-valores","text":"Clase Cr\u00edtico Esquivar Adicional GUERRERO 0.15 0.04 0.10 ARQUERO 0.22 0.18 0.22 MAGO 0.17 0.05 0.12 LUCHADOR 0.16 0.07 0.14 ESPIRITUALISTA 0.18 0.09 0.13 ASTRAL 0.20 0.10 0.18 Si se pasa una clase desconocida (o un enemigo), se devuelve un conjunto de probabilidades neutras por defecto ( 0.10 en cada categor\u00eda).","title":"Clases definidas y sus valores:"},{"location":"core-probabilidades/#probabilidades-de-combate","text":"","title":"\u2694\ufe0f Probabilidades de combate"},{"location":"core-probabilidades/#criticoobjetivo","text":"Determina si el ataque del objetivo resulta en un golpe cr\u00edtico. Extrae la clase del objetivo , obtiene su probabilidad correspondiente y ejecuta una tirada() . Devuelve True si se produce un cr\u00edtico, False en caso contrario.","title":"critico(objetivo)"},{"location":"core-probabilidades/#esquivarobjetivo","text":"Determina si el objetivo logra esquivar un ataque recibido. Funciona igual que critico() , pero evaluando la probabilidad de esquiva.","title":"esquivar(objetivo)"},{"location":"core-probabilidades/#adicionalobjetivo","text":"Determina si el objetivo realiza un segundo ataque en el mismo turno. Se usa com\u00fanmente tras realizar un accion_basica() para verificar si se repite el ataque.","title":"adicional(objetivo)"},{"location":"core-probabilidades/#relacion-con-otros-modulos","text":"El m\u00f3dulo probabilidades.py es utilizado directamente en: jugador.py y enemigos.py , durante las funciones accion_basica() , ataque_adicional() y c\u00e1lculo de calcular_golpe_recibido() efectos.py , en aplicar_efecto_contrario() para verificar si un efecto logra aplicarse Su dise\u00f1o garantiza consistencia entre las clases y sus atributos probabil\u00edsticos, generando una experiencia de combate variada y equilibrada.","title":"\ud83e\udde9 Relaci\u00f3n con otros m\u00f3dulos"},{"location":"core-probabilidades/#conclusion","text":"El m\u00f3dulo probabilidades.py encapsula la l\u00f3gica de azar en el combate, permitiendo controlar con claridad qu\u00e9 tan probable es un efecto en funci\u00f3n de la clase del personaje. Es sencillo, reutilizable y act\u00faa como base para un sistema de combate din\u00e1mico y estrat\u00e9gico.","title":"\ud83e\udde0 Conclusi\u00f3n"},{"location":"core-session/","text":"\ud83d\uddc2\ufe0f Limpieza de Sesi\u00f3n de Combate ( session.py ) \u00b6 Este m\u00f3dulo ofrece una \u00fanica funci\u00f3n: eliminar de la sesi\u00f3n del usuario todos los datos relacionados con un combate. Su prop\u00f3sito es garantizar que, una vez finalizado un combate (ya sea por victoria, derrota o abandono), el sistema no conserve estad\u00edsticas temporales o indicadores de estado innecesarios. \ud83e\uddf9 Limpieza de sesi\u00f3n \u00b6 limpiar_sesion_combate(request, combate_id) \u00b6 Elimina de la sesi\u00f3n del usuario todas las claves asociadas al combate con ID proporcionado. stats_jugador : estad\u00edsticas temporales del jugador. stats_enemigo : estad\u00edsticas temporales del enemigo. combate_{combate_id}_iniciado : bandera que marca si el combate ya se ha inicializado en sesi\u00f3n. Utiliza session.pop(clave, None) para eliminar cada clave sin lanzar errores si no existe. \ud83e\udde9 Relaci\u00f3n con otros m\u00f3dulos \u00b6 Usado en utils_resolvedor.py , tanto en resolver_victoria() como en resolver_derrota() para limpiar la sesi\u00f3n tras finalizar el combate. Garantiza que futuros combates empiecen con una sesi\u00f3n limpia, evitando estados corruptos o residuales. \ud83e\udde0 Conclusi\u00f3n \u00b6 Aunque sencillo, el m\u00f3dulo session.py cumple una funci\u00f3n cr\u00edtica: limpiar adecuadamente los datos de combate en sesi\u00f3n para asegurar un flujo correcto en nuevos enfrentamientos. Esta limpieza ayuda a mantener la integridad del sistema de combate entre partidas.","title":"\ud83d\uddc2\ufe0f Limpieza de Sesi\u00f3n de Combate (session.py)"},{"location":"core-session/#limpieza-de-sesion-de-combate-sessionpy","text":"Este m\u00f3dulo ofrece una \u00fanica funci\u00f3n: eliminar de la sesi\u00f3n del usuario todos los datos relacionados con un combate. Su prop\u00f3sito es garantizar que, una vez finalizado un combate (ya sea por victoria, derrota o abandono), el sistema no conserve estad\u00edsticas temporales o indicadores de estado innecesarios.","title":"\ud83d\uddc2\ufe0f Limpieza de Sesi\u00f3n de Combate (session.py)"},{"location":"core-session/#limpieza-de-sesion","text":"","title":"\ud83e\uddf9 Limpieza de sesi\u00f3n"},{"location":"core-session/#limpiar_sesion_combaterequest-combate_id","text":"Elimina de la sesi\u00f3n del usuario todas las claves asociadas al combate con ID proporcionado. stats_jugador : estad\u00edsticas temporales del jugador. stats_enemigo : estad\u00edsticas temporales del enemigo. combate_{combate_id}_iniciado : bandera que marca si el combate ya se ha inicializado en sesi\u00f3n. Utiliza session.pop(clave, None) para eliminar cada clave sin lanzar errores si no existe.","title":"limpiar_sesion_combate(request, combate_id)"},{"location":"core-session/#relacion-con-otros-modulos","text":"Usado en utils_resolvedor.py , tanto en resolver_victoria() como en resolver_derrota() para limpiar la sesi\u00f3n tras finalizar el combate. Garantiza que futuros combates empiecen con una sesi\u00f3n limpia, evitando estados corruptos o residuales.","title":"\ud83e\udde9 Relaci\u00f3n con otros m\u00f3dulos"},{"location":"core-session/#conclusion","text":"Aunque sencillo, el m\u00f3dulo session.py cumple una funci\u00f3n cr\u00edtica: limpiar adecuadamente los datos de combate en sesi\u00f3n para asegurar un flujo correcto en nuevos enfrentamientos. Esta limpieza ayuda a mantener la integridad del sistema de combate entre partidas.","title":"\ud83e\udde0 Conclusi\u00f3n"},{"location":"core-utils-combate/","text":"\ud83d\udee0\ufe0f Utilidades de Combate ( utils_combate.py ) \u00b6 Este m\u00f3dulo proporciona funciones auxiliares para interpretar los efectos de las habilidades tanto de jugadores como de los enemigos. Su objetivo es abstraer el acceso a los datos del campo efecto y garantizar que siempre se pueda obtener una representaci\u00f3n unificada. Estas utilidades son fundamentales para que m\u00f3dulos como jugador.py , enemigos.py o efectos.py puedan trabajar con habilidades sin preocuparse por su estructura interna. \ud83d\udce5 Interpretaci\u00f3n de efectos individuales \u00b6 leer_efecto(habilidad, campo, default=None) \u00b6 Devuelve el valor de un campo espec\u00edfico desde el atributo efecto de una habilidad. Si la habilidad pertenece a un jugador , extrae directamente el diccionario habilidad.efecto . Si la habilidad es de un enemigo , accede a habilidad.efecto . Si el campo no existe o el formato es incorrecto, devuelve default . \ud83d\udd0d Este m\u00e9todo es \u00fatil para acceder a campos como \"tipo\" , \"stat\" , \"valor\" , \"porcentaje\" o \"duracion\" desde cualquier habilidad. \ud83e\uddea Interpretaci\u00f3n de efectos m\u00faltiples \u00b6 leer_efectos(habilidad) \u00b6 Devuelve una lista de efectos aplicables desde una habilidad. Si el campo efecto es una lista , la retorna tal cual. Si es un diccionario con clave efectos , retorna el contenido de esa clave. Si es un diccionario simple , lo envuelve en una lista. Si no hay efectos reconocibles, devuelve una lista vac\u00eda. \u2705 Este m\u00e9todo garantiza que cualquier habilidad \u2014por simple o compleja que sea\u2014 pueda ser tratada como una lista de efectos en el sistema de combate. \ud83e\udde9 Relaci\u00f3n con otros m\u00f3dulos \u00b6 En jugador.py y enemigos.py , estas funciones son invocadas desde usar_habilidad() y usar_habilidad_enemigo() , respectivamente. En efectos.py , los efectos devueltos por leer_efectos() son aplicados con aplicar_estado() o aplicar_efecto_contrario() . \ud83e\udde0 Conclusi\u00f3n \u00b6 El m\u00f3dulo utils_combate.py aporta una capa de compatibilidad y uniformidad al tratamiento de habilidades en el combate. Gracias a estas funciones, el sistema es capaz de manejar habilidades con estructuras variadas sin comprometer la robustez del flujo de combate.","title":"Utilidades de Combate"},{"location":"core-utils-combate/#utilidades-de-combate-utils_combatepy","text":"Este m\u00f3dulo proporciona funciones auxiliares para interpretar los efectos de las habilidades tanto de jugadores como de los enemigos. Su objetivo es abstraer el acceso a los datos del campo efecto y garantizar que siempre se pueda obtener una representaci\u00f3n unificada. Estas utilidades son fundamentales para que m\u00f3dulos como jugador.py , enemigos.py o efectos.py puedan trabajar con habilidades sin preocuparse por su estructura interna.","title":"\ud83d\udee0\ufe0f Utilidades de Combate (utils_combate.py)"},{"location":"core-utils-combate/#interpretacion-de-efectos-individuales","text":"","title":"\ud83d\udce5 Interpretaci\u00f3n de efectos individuales"},{"location":"core-utils-combate/#leer_efectohabilidad-campo-defaultnone","text":"Devuelve el valor de un campo espec\u00edfico desde el atributo efecto de una habilidad. Si la habilidad pertenece a un jugador , extrae directamente el diccionario habilidad.efecto . Si la habilidad es de un enemigo , accede a habilidad.efecto . Si el campo no existe o el formato es incorrecto, devuelve default . \ud83d\udd0d Este m\u00e9todo es \u00fatil para acceder a campos como \"tipo\" , \"stat\" , \"valor\" , \"porcentaje\" o \"duracion\" desde cualquier habilidad.","title":"leer_efecto(habilidad, campo, default=None)"},{"location":"core-utils-combate/#interpretacion-de-efectos-multiples","text":"","title":"\ud83e\uddea Interpretaci\u00f3n de efectos m\u00faltiples"},{"location":"core-utils-combate/#leer_efectoshabilidad","text":"Devuelve una lista de efectos aplicables desde una habilidad. Si el campo efecto es una lista , la retorna tal cual. Si es un diccionario con clave efectos , retorna el contenido de esa clave. Si es un diccionario simple , lo envuelve en una lista. Si no hay efectos reconocibles, devuelve una lista vac\u00eda. \u2705 Este m\u00e9todo garantiza que cualquier habilidad \u2014por simple o compleja que sea\u2014 pueda ser tratada como una lista de efectos en el sistema de combate.","title":"leer_efectos(habilidad)"},{"location":"core-utils-combate/#relacion-con-otros-modulos","text":"En jugador.py y enemigos.py , estas funciones son invocadas desde usar_habilidad() y usar_habilidad_enemigo() , respectivamente. En efectos.py , los efectos devueltos por leer_efectos() son aplicados con aplicar_estado() o aplicar_efecto_contrario() .","title":"\ud83e\udde9 Relaci\u00f3n con otros m\u00f3dulos"},{"location":"core-utils-combate/#conclusion","text":"El m\u00f3dulo utils_combate.py aporta una capa de compatibilidad y uniformidad al tratamiento de habilidades en el combate. Gracias a estas funciones, el sistema es capaz de manejar habilidades con estructuras variadas sin comprometer la robustez del flujo de combate.","title":"\ud83e\udde0 Conclusi\u00f3n"},{"location":"core-utils-resolvedor/","text":"\ud83e\udde9 Resoluci\u00f3n de Turnos y Combates ( utils_resolvedor.py ) \u00b6 Este m\u00f3dulo orquesta las transiciones globales de cada combate: desde la inicializaci\u00f3n de los datos hasta la aplicaci\u00f3n de efectos y la resoluci\u00f3n de victorias o derrotas. Act\u00faa como un controlador l\u00f3gico que mantiene la integridad del combate turno a turno, manipulando el estado de la sesi\u00f3n, aplicando efectos y finalizando el combate cuando corresponde. Su dise\u00f1o mantiene el flujo general del combate separado de la l\u00f3gica de ataque o habilidad, facilitando una estructura m\u00e1s modular. \u2699\ufe0f Inicializaci\u00f3n de combate \u00b6 inicializar_combate(request, combate) \u00b6 Carga las estad\u00edsticas temporales de jugador y enemigo en la sesi\u00f3n si a\u00fan no han sido inicializadas. Usa la funci\u00f3n obtener_stats_temporales() desde estadisticas.py . Guarda las estad\u00edsticas bajo las claves \"stats_jugador\" y \"stats_enemigo\" en la sesi\u00f3n del usuario. Marca la sesi\u00f3n como iniciada con la clave \"combate_{id}_iniciado\" . Este paso es esencial para que todas las operaciones posteriores (ataques, efectos, etc.) trabajen con un estado aislado y modificable turno a turno. \u2620\ufe0f Aplicaci\u00f3n de efectos por turno \u00b6 registrar_efecto_turno(stats_obj, objeto, log) \u00b6 Aplica los efectos de estado que est\u00e9n activos y registra los resultados en el log del combate. Llama a procesar_estados() para aplicar efectos (venenos, regeneraciones, etc.). Luego, invoca limpiar_estados_expirados() para remover efectos cuya duraci\u00f3n haya terminado. Todos los mensajes generados se agregan al log . Este m\u00e9todo se ejecuta al inicio del turno para mantener el sistema de efectos sincronizado con el flujo del combate. \ud83c\udfc6 Resoluci\u00f3n de victoria \u00b6 resolver_victoria(request, jugador, enemigo, combate) \u00b6 Finaliza el combate declarando al jugador como vencedor. Actualiza los valores definitivos del jugador con actualizar_stats_finales() . Cambia el estado del combate: terminado = True , resultado = \"victoria\" . Otorga experiencia al jugador con ganar_experiencia() . Elimina los datos de combate de la sesi\u00f3n con limpiar_sesion_combate() . Aumenta el contador de victorias del jugador. Redirige al usuario a la vista resultado_combate . \ud83d\udc80 Resoluci\u00f3n de derrota \u00b6 resolver_derrota(request, jugador, combate) \u00b6 Finaliza el combate indicando que el jugador ha perdido. Similar a resolver_victoria() , pero sin otorgar experiencia. Marca resultado = \"derrota\" y aumenta las derrotas del jugador. Limpia sesi\u00f3n y redirige al resultado del combate. \ud83e\udde9 Relaci\u00f3n con otros m\u00f3dulos \u00b6 Invocado desde views.py y combate.py , principalmente tras evaluar los efectos de cada acci\u00f3n. Depende de funciones de los m\u00f3dulos: estadisticas.py para las estad\u00edsticas temporales efectos.py para el manejo de estados jugador.py para la experiencia y resultados session.py para la limpieza de datos de combate \ud83e\udde0 Conclusi\u00f3n \u00b6 El m\u00f3dulo utils_resolvedor.py centraliza la l\u00f3gica del flujo de combate en torno a la sesi\u00f3n, efectos y finalizaci\u00f3n. Gracias a su estructura, garantiza un control coherente del estado global del combate, separando responsabilidades entre los m\u00f3dulos de acci\u00f3n y el sistema de control general.","title":"Resoluci\u00f3n de Turnos"},{"location":"core-utils-resolvedor/#resolucion-de-turnos-y-combates-utils_resolvedorpy","text":"Este m\u00f3dulo orquesta las transiciones globales de cada combate: desde la inicializaci\u00f3n de los datos hasta la aplicaci\u00f3n de efectos y la resoluci\u00f3n de victorias o derrotas. Act\u00faa como un controlador l\u00f3gico que mantiene la integridad del combate turno a turno, manipulando el estado de la sesi\u00f3n, aplicando efectos y finalizando el combate cuando corresponde. Su dise\u00f1o mantiene el flujo general del combate separado de la l\u00f3gica de ataque o habilidad, facilitando una estructura m\u00e1s modular.","title":"\ud83e\udde9 Resoluci\u00f3n de Turnos y Combates (utils_resolvedor.py)"},{"location":"core-utils-resolvedor/#inicializacion-de-combate","text":"","title":"\u2699\ufe0f Inicializaci\u00f3n de combate"},{"location":"core-utils-resolvedor/#inicializar_combaterequest-combate","text":"Carga las estad\u00edsticas temporales de jugador y enemigo en la sesi\u00f3n si a\u00fan no han sido inicializadas. Usa la funci\u00f3n obtener_stats_temporales() desde estadisticas.py . Guarda las estad\u00edsticas bajo las claves \"stats_jugador\" y \"stats_enemigo\" en la sesi\u00f3n del usuario. Marca la sesi\u00f3n como iniciada con la clave \"combate_{id}_iniciado\" . Este paso es esencial para que todas las operaciones posteriores (ataques, efectos, etc.) trabajen con un estado aislado y modificable turno a turno.","title":"inicializar_combate(request, combate)"},{"location":"core-utils-resolvedor/#aplicacion-de-efectos-por-turno","text":"","title":"\u2620\ufe0f Aplicaci\u00f3n de efectos por turno"},{"location":"core-utils-resolvedor/#registrar_efecto_turnostats_obj-objeto-log","text":"Aplica los efectos de estado que est\u00e9n activos y registra los resultados en el log del combate. Llama a procesar_estados() para aplicar efectos (venenos, regeneraciones, etc.). Luego, invoca limpiar_estados_expirados() para remover efectos cuya duraci\u00f3n haya terminado. Todos los mensajes generados se agregan al log . Este m\u00e9todo se ejecuta al inicio del turno para mantener el sistema de efectos sincronizado con el flujo del combate.","title":"registrar_efecto_turno(stats_obj, objeto, log)"},{"location":"core-utils-resolvedor/#resolucion-de-victoria","text":"","title":"\ud83c\udfc6 Resoluci\u00f3n de victoria"},{"location":"core-utils-resolvedor/#resolver_victoriarequest-jugador-enemigo-combate","text":"Finaliza el combate declarando al jugador como vencedor. Actualiza los valores definitivos del jugador con actualizar_stats_finales() . Cambia el estado del combate: terminado = True , resultado = \"victoria\" . Otorga experiencia al jugador con ganar_experiencia() . Elimina los datos de combate de la sesi\u00f3n con limpiar_sesion_combate() . Aumenta el contador de victorias del jugador. Redirige al usuario a la vista resultado_combate .","title":"resolver_victoria(request, jugador, enemigo, combate)"},{"location":"core-utils-resolvedor/#resolucion-de-derrota","text":"","title":"\ud83d\udc80 Resoluci\u00f3n de derrota"},{"location":"core-utils-resolvedor/#resolver_derrotarequest-jugador-combate","text":"Finaliza el combate indicando que el jugador ha perdido. Similar a resolver_victoria() , pero sin otorgar experiencia. Marca resultado = \"derrota\" y aumenta las derrotas del jugador. Limpia sesi\u00f3n y redirige al resultado del combate.","title":"resolver_derrota(request, jugador, combate)"},{"location":"core-utils-resolvedor/#relacion-con-otros-modulos","text":"Invocado desde views.py y combate.py , principalmente tras evaluar los efectos de cada acci\u00f3n. Depende de funciones de los m\u00f3dulos: estadisticas.py para las estad\u00edsticas temporales efectos.py para el manejo de estados jugador.py para la experiencia y resultados session.py para la limpieza de datos de combate","title":"\ud83e\udde9 Relaci\u00f3n con otros m\u00f3dulos"},{"location":"core-utils-resolvedor/#conclusion","text":"El m\u00f3dulo utils_resolvedor.py centraliza la l\u00f3gica del flujo de combate en torno a la sesi\u00f3n, efectos y finalizaci\u00f3n. Gracias a su estructura, garantiza un control coherente del estado global del combate, separando responsabilidades entre los m\u00f3dulos de acci\u00f3n y el sistema de control general.","title":"\ud83e\udde0 Conclusi\u00f3n"},{"location":"despliegue/","text":"\ud83d\ude80 Despliegue del Proyecto \u00b6 Battlebound Tactics ha sido dise\u00f1ado para poder desplegarse f\u00e1cilmente tanto en un entorno de desarrollo local como en un servidor en la nube (AWS), utilizando Docker como sistema de contenedores. A continuaci\u00f3n, detallo el proceso completo de despliegue en ambas modalidades, as\u00ed como los archivos utilizados para lograrlo. \ud83d\udc33 Contenedorizaci\u00f3n con Docker \u00b6 Todo el proyecto se ha encapsulado en un entorno Docker, asegurando consistencia entre entornos de desarrollo y producci\u00f3n. Esto incluye: El backend con Django y sus dependencias. La base de datos PostgreSQL , tanto en local como en producci\u00f3n. Configuraci\u00f3n de variables de entorno (gestionadas por archivos .env ). Automatizaci\u00f3n del despliegue mediante GitHub Actions . \ud83d\udcc1 Archivos de despliegue \u00b6 Archivo Descripci\u00f3n Dockerfile Define la imagen base del proyecto. Instala dependencias, copia el c\u00f3digo y lanza el servidor. compose.yml Archivo principal para el despliegue en AWS . Usa PostgreSQL y est\u00e1 optimizado para producci\u00f3n. compose_local.yml Versi\u00f3n adaptada para entorno de desarrollo local. docker_aws.yml Workflow de GitHub Actions que automatiza la construcci\u00f3n, subida de imagen y despliegue en AWS. \ud83c\udfd7\ufe0f Dockerfile: Imagen base del proyecto \u00b6 Este archivo construye la imagen principal de Battlebound Tactics. Pasos que realiza: \u00b6 Utiliza una imagen oficial de Python como base. Instala las dependencias del proyecto desde requirements.txt . Copia todo el c\u00f3digo del proyecto dentro del contenedor. Expone el puerto 8000. Ejecuta el servidor de Django en el puerto 0.0.0.0:8000 . Comando final de ejecuci\u00f3n: \u00b6 python manage.py runserver 0.0.0.0:8000 \ud83d\udcbb Despliegue local: compose_local.yml \u00b6 Este archivo se usa para desarrollo en entorno local. Caracter\u00edsticas: \u00b6 Define un servicio web que ejecuta la aplicaci\u00f3n Django. Expone el puerto 8000 en el host. Usa vol\u00famenes para mantener sincronizado el c\u00f3digo entre el host y el contenedor. Conecta con un contenedor de base de datos PostgreSQL tambi\u00e9n definido en el archivo. Comando para ejecutarlo: \u00b6 docker compose -f compose_local.yml up --build \u2601\ufe0f Despliegue en producci\u00f3n: compose.yml \u00b6 Este archivo es el utilizado para el despliegue real en AWS . Est\u00e1 adaptado para correr la aplicaci\u00f3n en un servidor EC2 con Docker. Caracter\u00edsticas: \u00b6 Lanza dos servicios principales: app (Battlebound Tactics) y db (PostgreSQL). Usa traefik como reverse-proxy. Conecta a una base de datos PostgreSQL real y persistente. Exposici\u00f3n de puertos y variables de entorno seg\u00fan la configuraci\u00f3n definida en .env . Comando de despliegue en AWS: \u00b6 docker compose up -d \ud83e\udd16 Despliegue automatizado: docker_aws.yml (GitHub Actions) \u00b6 Este archivo no es parte del despliegue manual, sino una automatizaci\u00f3n que se ejecuta al hacer push o pull request en el repositorio de GitHub. Funcionalidad: \u00b6 Se activa en eventos del repositorio. Construye una nueva imagen Docker a partir del c\u00f3digo actualizado. Sube la imagen actualizada a Docker Hub. Se conecta por SSH a la instancia EC2 de AWS. Detiene cualquier contenedor anterior y lanza uno nuevo con la imagen actualizada. Gracias a este sistema, no es necesario acceder manualmente al servidor para desplegar una nueva versi\u00f3n: basta con hacer push al repositorio. \ud83d\udce6 Resultado \u00b6 Al completar el proceso de despliegue, el proyecto queda corriendo en un contenedor Docker en AWS, utilizando PostgreSQL como base de datos y estando completamente accesible desde su dominio vinculado ( jonatan-daw2.tech ). Adem\u00e1s, con la automatizaci\u00f3n configurada, cualquier cambio en el repositorio se refleja autom\u00e1ticamente tras cada push.","title":"\ud83d\ude80 Despliegue y Configuraci\u00f3n"},{"location":"despliegue/#despliegue-del-proyecto","text":"Battlebound Tactics ha sido dise\u00f1ado para poder desplegarse f\u00e1cilmente tanto en un entorno de desarrollo local como en un servidor en la nube (AWS), utilizando Docker como sistema de contenedores. A continuaci\u00f3n, detallo el proceso completo de despliegue en ambas modalidades, as\u00ed como los archivos utilizados para lograrlo.","title":"\ud83d\ude80 Despliegue del Proyecto"},{"location":"despliegue/#contenedorizacion-con-docker","text":"Todo el proyecto se ha encapsulado en un entorno Docker, asegurando consistencia entre entornos de desarrollo y producci\u00f3n. Esto incluye: El backend con Django y sus dependencias. La base de datos PostgreSQL , tanto en local como en producci\u00f3n. Configuraci\u00f3n de variables de entorno (gestionadas por archivos .env ). Automatizaci\u00f3n del despliegue mediante GitHub Actions .","title":"\ud83d\udc33 Contenedorizaci\u00f3n con Docker"},{"location":"despliegue/#archivos-de-despliegue","text":"Archivo Descripci\u00f3n Dockerfile Define la imagen base del proyecto. Instala dependencias, copia el c\u00f3digo y lanza el servidor. compose.yml Archivo principal para el despliegue en AWS . Usa PostgreSQL y est\u00e1 optimizado para producci\u00f3n. compose_local.yml Versi\u00f3n adaptada para entorno de desarrollo local. docker_aws.yml Workflow de GitHub Actions que automatiza la construcci\u00f3n, subida de imagen y despliegue en AWS.","title":"\ud83d\udcc1 Archivos de despliegue"},{"location":"despliegue/#dockerfile-imagen-base-del-proyecto","text":"Este archivo construye la imagen principal de Battlebound Tactics.","title":"\ud83c\udfd7\ufe0f Dockerfile: Imagen base del proyecto"},{"location":"despliegue/#pasos-que-realiza","text":"Utiliza una imagen oficial de Python como base. Instala las dependencias del proyecto desde requirements.txt . Copia todo el c\u00f3digo del proyecto dentro del contenedor. Expone el puerto 8000. Ejecuta el servidor de Django en el puerto 0.0.0.0:8000 .","title":"Pasos que realiza:"},{"location":"despliegue/#comando-final-de-ejecucion","text":"python manage.py runserver 0.0.0.0:8000","title":"Comando final de ejecuci\u00f3n:"},{"location":"despliegue/#despliegue-local-compose_localyml","text":"Este archivo se usa para desarrollo en entorno local.","title":"\ud83d\udcbb Despliegue local: compose_local.yml"},{"location":"despliegue/#caracteristicas","text":"Define un servicio web que ejecuta la aplicaci\u00f3n Django. Expone el puerto 8000 en el host. Usa vol\u00famenes para mantener sincronizado el c\u00f3digo entre el host y el contenedor. Conecta con un contenedor de base de datos PostgreSQL tambi\u00e9n definido en el archivo.","title":"Caracter\u00edsticas:"},{"location":"despliegue/#comando-para-ejecutarlo","text":"docker compose -f compose_local.yml up --build","title":"Comando para ejecutarlo:"},{"location":"despliegue/#despliegue-en-produccion-composeyml","text":"Este archivo es el utilizado para el despliegue real en AWS . Est\u00e1 adaptado para correr la aplicaci\u00f3n en un servidor EC2 con Docker.","title":"\u2601\ufe0f Despliegue en producci\u00f3n: compose.yml"},{"location":"despliegue/#caracteristicas_1","text":"Lanza dos servicios principales: app (Battlebound Tactics) y db (PostgreSQL). Usa traefik como reverse-proxy. Conecta a una base de datos PostgreSQL real y persistente. Exposici\u00f3n de puertos y variables de entorno seg\u00fan la configuraci\u00f3n definida en .env .","title":"Caracter\u00edsticas:"},{"location":"despliegue/#comando-de-despliegue-en-aws","text":"docker compose up -d","title":"Comando de despliegue en AWS:"},{"location":"despliegue/#despliegue-automatizado-docker_awsyml-github-actions","text":"Este archivo no es parte del despliegue manual, sino una automatizaci\u00f3n que se ejecuta al hacer push o pull request en el repositorio de GitHub.","title":"\ud83e\udd16 Despliegue automatizado: docker_aws.yml (GitHub Actions)"},{"location":"despliegue/#funcionalidad","text":"Se activa en eventos del repositorio. Construye una nueva imagen Docker a partir del c\u00f3digo actualizado. Sube la imagen actualizada a Docker Hub. Se conecta por SSH a la instancia EC2 de AWS. Detiene cualquier contenedor anterior y lanza uno nuevo con la imagen actualizada. Gracias a este sistema, no es necesario acceder manualmente al servidor para desplegar una nueva versi\u00f3n: basta con hacer push al repositorio.","title":"Funcionalidad:"},{"location":"despliegue/#resultado","text":"Al completar el proceso de despliegue, el proyecto queda corriendo en un contenedor Docker en AWS, utilizando PostgreSQL como base de datos y estando completamente accesible desde su dominio vinculado ( jonatan-daw2.tech ). Adem\u00e1s, con la automatizaci\u00f3n configurada, cualquier cambio en el repositorio se refleja autom\u00e1ticamente tras cada push.","title":"\ud83d\udce6 Resultado"},{"location":"logica-combate/","text":"\u2694\ufe0f Vista de Combate: combate(request, combate_id) \u00b6 Decoradores : @login_required Par\u00e1metros : request : la solicitud del jugador. combate_id : identificador del combate actual. La vista combate es el coraz\u00f3n del sistema jugable de Battlebound Tactics. Aqu\u00ed ocurre toda la l\u00f3gica de combate por turnos entre el jugador y el enemigo. Esta vista gestiona turnos, efectos de estado, resoluci\u00f3n de acciones, condiciones de victoria o derrota y sincronizaci\u00f3n del estado del combate. M\u00f3dulos \u00b6 Si desea conocer m\u00e1s a fondo los m\u00f3dulos que componen Battlebound Tactics, puede echar un vistazo a esta tabla de contenidos, en ella, podr\u00e1s encontrar enlaces a la documentaci\u00f3n de cada archivo \ud83c\udfae M\u00f3dulos del juego, dentro de core/ M\u00f3dulo Descripci\u00f3n jugador.py Controla la l\u00f3gica del jugador durante el combate: ataques, habilidades, energ\u00eda, salud. enemigos.py Implementa la IA enemiga. Decide acciones seg\u00fan el estado del combate, controla habilidades y cooldowns. efectos.py Sistema de estados: veneno, buffs, debuffs, curaciones. Aplica y gestiona sus duraciones y efectos. estadisticas.py Calcula estad\u00edsticas finales del jugador/enemigo: ataque, defensa, velocidad, etc. seg\u00fan nivel, pasiva y equipo. probabilidades.py Define y gestiona las probabilidades de efectos como cr\u00edticos, evasi\u00f3n, adicionales, etc. utils_combate.py Funciones auxiliares para interpretar efectos y habilidades. utils_resolvedor.py Controla la secuencia de turnos, efectos globales por turno, condiciones de victoria o derrota. session.py Controla la secuencia de turnos, efectos globales por turno, condiciones de victoria o derrota. \ud83c\udfac Autorizaci\u00f3n y control de acceso \u00b6 Al comenzar, se recupera el combate mediante su ID. Se verifica que el usuario autenticado sea el propietario del combate. Si no lo es, se bloquea el acceso lanzando una excepci\u00f3n. Adem\u00e1s, si el combate ya ha terminado, se redirige autom\u00e1ticamente a la vista de resultado, para evitar que se repita o se acceda a un estado inconsistente. \u2699\ufe0f Inicializaci\u00f3n del combate \u00b6 Se inicializan las estad\u00edsticas del jugador y del enemigo a trav\u00e9s de una funci\u00f3n espec\u00edfica que calcula salud, energ\u00eda, velocidad, evasi\u00f3n, da\u00f1o y otros modificadores. Esto incluye factores como la clase del jugador, su equipo, su nivel y sus pasivas. Tambi\u00e9n se crea una copia temporal del estado del enemigo antes del turno. Esto servir\u00e1 m\u00e1s adelante para saber si recibi\u00f3 da\u00f1o, y mostrar una animaci\u00f3n de impacto. \ud83d\udca1 Aplicaci\u00f3n de efectos al inicio del turno \u00b6 Al inicio de cada turno se aplican los efectos de estado activos en cada personaje. Primero se aplican los efectos del enemigo, otorg\u00e1ndole una ligera ventaja al jugador. Luego, se aplican los del jugador. Estos efectos pueden ser beneficiosos (curaci\u00f3n, aumentos de defensa) o perjudiciales (veneno, reducci\u00f3n de estad\u00edsticas). Si alguno de los dos muere por un efecto, se detiene el flujo, se asigna una victoria o derrota al combate y se redirige a la vista de resultado correspondiente \ud83d\udce5 Procesamiento de la acci\u00f3n del jugador \u00b6 Cuando el jugador realiza una acci\u00f3n (por ejemplo, atacar o usar una habilidad), esta llega a trav\u00e9s de un formulario. Si no se detecta ninguna acci\u00f3n, se muestra un mensaje de error en el registro del combate. \u23f1\ufe0f Prioridad por velocidad \u00b6 Antes de ejecutar los turnos, se compara la estad\u00edstica de velocidad del jugador y del enemigo. Quien tenga m\u00e1s velocidad act\u00faa primero. Si est\u00e1n empatados, el jugador tiene prioridad. \ud83d\udd01 Ciclo de turnos \u00b6 Dependiendo de qui\u00e9n act\u00fae primero, se siguen dos posibles flujos: Si el jugador act\u00faa primero: \u00b6 El jugador realiza su acci\u00f3n. Si el enemigo muere, el combate termina con victoria. Si sigue vivo, el enemigo realiza su acci\u00f3n. Si el jugador muere, el combate termina con derrota. Si el enemigo act\u00faa primero: \u00b6 El enemigo realiza su acci\u00f3n. Si el jugador muere, termina en derrota. Si sigue vivo, el jugador ejecuta su turno. Si el enemigo muere, termina en victoria. Este sistema garantiza que ambos personajes puedan actuar, pero da ventaja a quien tenga mayor velocidad. \ud83d\udca2 Detecci\u00f3n de da\u00f1o y animaci\u00f3n \u00b6 Despu\u00e9s de ejecutar ambos turnos, se compara la salud del enemigo antes y despu\u00e9s. Si ha cambiado, se activa una animaci\u00f3n visual en pantalla para indicar que ha recibido da\u00f1o. Esta animaci\u00f3n se elige aleatoriamente entre varias disponibles, para darle dinamismo al combate. \ud83d\udcbe Persistencia de las estad\u00edsticas \u00b6 Al final del turno, las estad\u00edsticas de ambos personajes se almacenan en sesi\u00f3n. Tambi\u00e9n se incrementa el contador de turnos del combate y se guarda la instancia en la base de datos. Esto asegura que, incluso si se recarga la p\u00e1gina, el estado actual del combate se conserva correctamente. \ud83e\uddfe Renderizado de la vista \u00b6 La plantilla del combate se renderiza con todos los datos relevantes: Estad\u00edsticas del jugador y del enemigo. Registro de acciones realizadas durante el turno. Estado del combate. Posibles animaciones activadas. Acciones disponibles para el pr\u00f3ximo turno. La interfaz refleja todo lo que ocurre durante la batalla, y ofrece una experiencia fluida y visualmente agradable. \ud83d\udcc8 Funciones clave utilizadas \u00b6 Esta vista depende fuertemente de funciones auxiliares, como: Una funci\u00f3n para inicializar el combate. inicializar_combate(request, combate) Otra para aplicar los efectos de turno. registrar_efecto_turno(stats_enemigo, enemigo, log) , registrar_efecto_turno(stats_jugador, jugador, log) Una funci\u00f3n dedicada al turno del jugador, que interpreta la acci\u00f3n y ejecuta su acci\u00f3n. ejecutar_turno_jugador(request, jugador, combate, stats_jugador, stats_enemigo, enemigo, accion, log) Una funci\u00f3n similar para el enemigo, basada en una inteligencia artificial. ejecutar_turno_enemigo(request, jugador, stats_jugador, stats_enemigo, enemigo, log, combate) Funciones que resuelven el combate en caso de victoria o derrota. resolver_victoria(request, jugador, enemigo, combate) , resolver_derrota(request, jugador, combate) Estas funciones est\u00e1n organizadas en los m\u00f3dulos del core ( jugador.py , enemigos.py , efectos.py , estadisticas.py , etc.) y permiten mantener la l\u00f3gica bien modularizada. \ud83c\udfc1 Vista resultado_combate \u00b6 Esta vista se ejecuta inmediatamente despu\u00e9s de que el combate termina. Solo se encarga de mostrar al jugador lo que ha ocurrido: Si ha ganado o perdido. Calcular la experiencia obtenida y si ha subido de nivel. Se cargan todos los datos desde el modelo Combate y se pasan al contexto para renderizar la plantilla resultado.html . Aqu\u00ed no se ejecuta ninguna l\u00f3gica, solo presentaci\u00f3n. \ud83d\udd04 Flujo completo del combate \u00b6 [ iniciar_combate ] \u2193 [ Iniciamos las estad\u00edsticas/ las recuperamos de la sesi\u00f3n ] \u2193 [ Aplicamos los estados del enemigo y del jugador ] \u2193 [ Comprobamos victoria o derrota ] \u2193 [ Recogemos la acci\u00f3n del jugador ] \u2193 [ Decidimos quien va primero seg\u00fan la velociadad ] \u2193 [ Ejecutamos los turnos del enemigo y el jugador ] \u2193 [ Comprobamos victoria o derrota ] \u2190 Si nadie gana, se repite el flujo \u2193 [ resultado_combate ] \ud83e\udde0 Reflexi\u00f3n \u00b6 La vista combate est\u00e1 dise\u00f1ada para ofrecer una experiencia t\u00e1ctica rica y detallada, donde cada decisi\u00f3n cuenta. Su l\u00f3gica modular permite integrar efectos complejos, decisiones de IA y estad\u00edsticas din\u00e1micas. Este sistema se puede ampliar f\u00e1cilmente para incluir nuevas mec\u00e1nicas, como habilidades pasivas avanzadas, efectos en cadena o enemigos con fases. Es uno de los componentes m\u00e1s completos del proyecto, y demuestra el nivel de integraci\u00f3n entre frontend, backend y l\u00f3gica de juego.","title":"\u2694\ufe0f L\u00f3gica del combate"},{"location":"logica-combate/#vista-de-combate-combaterequest-combate_id","text":"Decoradores : @login_required Par\u00e1metros : request : la solicitud del jugador. combate_id : identificador del combate actual. La vista combate es el coraz\u00f3n del sistema jugable de Battlebound Tactics. Aqu\u00ed ocurre toda la l\u00f3gica de combate por turnos entre el jugador y el enemigo. Esta vista gestiona turnos, efectos de estado, resoluci\u00f3n de acciones, condiciones de victoria o derrota y sincronizaci\u00f3n del estado del combate.","title":"\u2694\ufe0f Vista de Combate: combate(request, combate_id)"},{"location":"logica-combate/#modulos","text":"Si desea conocer m\u00e1s a fondo los m\u00f3dulos que componen Battlebound Tactics, puede echar un vistazo a esta tabla de contenidos, en ella, podr\u00e1s encontrar enlaces a la documentaci\u00f3n de cada archivo \ud83c\udfae M\u00f3dulos del juego, dentro de core/ M\u00f3dulo Descripci\u00f3n jugador.py Controla la l\u00f3gica del jugador durante el combate: ataques, habilidades, energ\u00eda, salud. enemigos.py Implementa la IA enemiga. Decide acciones seg\u00fan el estado del combate, controla habilidades y cooldowns. efectos.py Sistema de estados: veneno, buffs, debuffs, curaciones. Aplica y gestiona sus duraciones y efectos. estadisticas.py Calcula estad\u00edsticas finales del jugador/enemigo: ataque, defensa, velocidad, etc. seg\u00fan nivel, pasiva y equipo. probabilidades.py Define y gestiona las probabilidades de efectos como cr\u00edticos, evasi\u00f3n, adicionales, etc. utils_combate.py Funciones auxiliares para interpretar efectos y habilidades. utils_resolvedor.py Controla la secuencia de turnos, efectos globales por turno, condiciones de victoria o derrota. session.py Controla la secuencia de turnos, efectos globales por turno, condiciones de victoria o derrota.","title":"M\u00f3dulos"},{"location":"logica-combate/#autorizacion-y-control-de-acceso","text":"Al comenzar, se recupera el combate mediante su ID. Se verifica que el usuario autenticado sea el propietario del combate. Si no lo es, se bloquea el acceso lanzando una excepci\u00f3n. Adem\u00e1s, si el combate ya ha terminado, se redirige autom\u00e1ticamente a la vista de resultado, para evitar que se repita o se acceda a un estado inconsistente.","title":"\ud83c\udfac Autorizaci\u00f3n y control de acceso"},{"location":"logica-combate/#inicializacion-del-combate","text":"Se inicializan las estad\u00edsticas del jugador y del enemigo a trav\u00e9s de una funci\u00f3n espec\u00edfica que calcula salud, energ\u00eda, velocidad, evasi\u00f3n, da\u00f1o y otros modificadores. Esto incluye factores como la clase del jugador, su equipo, su nivel y sus pasivas. Tambi\u00e9n se crea una copia temporal del estado del enemigo antes del turno. Esto servir\u00e1 m\u00e1s adelante para saber si recibi\u00f3 da\u00f1o, y mostrar una animaci\u00f3n de impacto.","title":"\u2699\ufe0f Inicializaci\u00f3n del combate"},{"location":"logica-combate/#aplicacion-de-efectos-al-inicio-del-turno","text":"Al inicio de cada turno se aplican los efectos de estado activos en cada personaje. Primero se aplican los efectos del enemigo, otorg\u00e1ndole una ligera ventaja al jugador. Luego, se aplican los del jugador. Estos efectos pueden ser beneficiosos (curaci\u00f3n, aumentos de defensa) o perjudiciales (veneno, reducci\u00f3n de estad\u00edsticas). Si alguno de los dos muere por un efecto, se detiene el flujo, se asigna una victoria o derrota al combate y se redirige a la vista de resultado correspondiente","title":"\ud83d\udca1 Aplicaci\u00f3n de efectos al inicio del turno"},{"location":"logica-combate/#procesamiento-de-la-accion-del-jugador","text":"Cuando el jugador realiza una acci\u00f3n (por ejemplo, atacar o usar una habilidad), esta llega a trav\u00e9s de un formulario. Si no se detecta ninguna acci\u00f3n, se muestra un mensaje de error en el registro del combate.","title":"\ud83d\udce5 Procesamiento de la acci\u00f3n del jugador"},{"location":"logica-combate/#prioridad-por-velocidad","text":"Antes de ejecutar los turnos, se compara la estad\u00edstica de velocidad del jugador y del enemigo. Quien tenga m\u00e1s velocidad act\u00faa primero. Si est\u00e1n empatados, el jugador tiene prioridad.","title":"\u23f1\ufe0f Prioridad por velocidad"},{"location":"logica-combate/#ciclo-de-turnos","text":"Dependiendo de qui\u00e9n act\u00fae primero, se siguen dos posibles flujos:","title":"\ud83d\udd01 Ciclo de turnos"},{"location":"logica-combate/#si-el-jugador-actua-primero","text":"El jugador realiza su acci\u00f3n. Si el enemigo muere, el combate termina con victoria. Si sigue vivo, el enemigo realiza su acci\u00f3n. Si el jugador muere, el combate termina con derrota.","title":"Si el jugador act\u00faa primero:"},{"location":"logica-combate/#si-el-enemigo-actua-primero","text":"El enemigo realiza su acci\u00f3n. Si el jugador muere, termina en derrota. Si sigue vivo, el jugador ejecuta su turno. Si el enemigo muere, termina en victoria. Este sistema garantiza que ambos personajes puedan actuar, pero da ventaja a quien tenga mayor velocidad.","title":"Si el enemigo act\u00faa primero:"},{"location":"logica-combate/#deteccion-de-dano-y-animacion","text":"Despu\u00e9s de ejecutar ambos turnos, se compara la salud del enemigo antes y despu\u00e9s. Si ha cambiado, se activa una animaci\u00f3n visual en pantalla para indicar que ha recibido da\u00f1o. Esta animaci\u00f3n se elige aleatoriamente entre varias disponibles, para darle dinamismo al combate.","title":"\ud83d\udca2 Detecci\u00f3n de da\u00f1o y animaci\u00f3n"},{"location":"logica-combate/#persistencia-de-las-estadisticas","text":"Al final del turno, las estad\u00edsticas de ambos personajes se almacenan en sesi\u00f3n. Tambi\u00e9n se incrementa el contador de turnos del combate y se guarda la instancia en la base de datos. Esto asegura que, incluso si se recarga la p\u00e1gina, el estado actual del combate se conserva correctamente.","title":"\ud83d\udcbe Persistencia de las estad\u00edsticas"},{"location":"logica-combate/#renderizado-de-la-vista","text":"La plantilla del combate se renderiza con todos los datos relevantes: Estad\u00edsticas del jugador y del enemigo. Registro de acciones realizadas durante el turno. Estado del combate. Posibles animaciones activadas. Acciones disponibles para el pr\u00f3ximo turno. La interfaz refleja todo lo que ocurre durante la batalla, y ofrece una experiencia fluida y visualmente agradable.","title":"\ud83e\uddfe Renderizado de la vista"},{"location":"logica-combate/#funciones-clave-utilizadas","text":"Esta vista depende fuertemente de funciones auxiliares, como: Una funci\u00f3n para inicializar el combate. inicializar_combate(request, combate) Otra para aplicar los efectos de turno. registrar_efecto_turno(stats_enemigo, enemigo, log) , registrar_efecto_turno(stats_jugador, jugador, log) Una funci\u00f3n dedicada al turno del jugador, que interpreta la acci\u00f3n y ejecuta su acci\u00f3n. ejecutar_turno_jugador(request, jugador, combate, stats_jugador, stats_enemigo, enemigo, accion, log) Una funci\u00f3n similar para el enemigo, basada en una inteligencia artificial. ejecutar_turno_enemigo(request, jugador, stats_jugador, stats_enemigo, enemigo, log, combate) Funciones que resuelven el combate en caso de victoria o derrota. resolver_victoria(request, jugador, enemigo, combate) , resolver_derrota(request, jugador, combate) Estas funciones est\u00e1n organizadas en los m\u00f3dulos del core ( jugador.py , enemigos.py , efectos.py , estadisticas.py , etc.) y permiten mantener la l\u00f3gica bien modularizada.","title":"\ud83d\udcc8 Funciones clave utilizadas"},{"location":"logica-combate/#vista-resultado_combate","text":"Esta vista se ejecuta inmediatamente despu\u00e9s de que el combate termina. Solo se encarga de mostrar al jugador lo que ha ocurrido: Si ha ganado o perdido. Calcular la experiencia obtenida y si ha subido de nivel. Se cargan todos los datos desde el modelo Combate y se pasan al contexto para renderizar la plantilla resultado.html . Aqu\u00ed no se ejecuta ninguna l\u00f3gica, solo presentaci\u00f3n.","title":"\ud83c\udfc1 Vista resultado_combate"},{"location":"logica-combate/#flujo-completo-del-combate","text":"[ iniciar_combate ] \u2193 [ Iniciamos las estad\u00edsticas/ las recuperamos de la sesi\u00f3n ] \u2193 [ Aplicamos los estados del enemigo y del jugador ] \u2193 [ Comprobamos victoria o derrota ] \u2193 [ Recogemos la acci\u00f3n del jugador ] \u2193 [ Decidimos quien va primero seg\u00fan la velociadad ] \u2193 [ Ejecutamos los turnos del enemigo y el jugador ] \u2193 [ Comprobamos victoria o derrota ] \u2190 Si nadie gana, se repite el flujo \u2193 [ resultado_combate ]","title":"\ud83d\udd04 Flujo completo del combate"},{"location":"logica-combate/#reflexion","text":"La vista combate est\u00e1 dise\u00f1ada para ofrecer una experiencia t\u00e1ctica rica y detallada, donde cada decisi\u00f3n cuenta. Su l\u00f3gica modular permite integrar efectos complejos, decisiones de IA y estad\u00edsticas din\u00e1micas. Este sistema se puede ampliar f\u00e1cilmente para incluir nuevas mec\u00e1nicas, como habilidades pasivas avanzadas, efectos en cadena o enemigos con fases. Es uno de los componentes m\u00e1s completos del proyecto, y demuestra el nivel de integraci\u00f3n entre frontend, backend y l\u00f3gica de juego.","title":"\ud83e\udde0 Reflexi\u00f3n"},{"location":"modelos/","text":"\ud83e\uddec Modelos del Proyecto \u00b6 Esta secci\u00f3n documenta todos los modelos utilizados en Battlebound Tactics , el videojuego web RPG de combate por turnos. Los modelos est\u00e1n definidos en Django ORM y conforman la base de datos del juego, incluyendo jugadores, enemigos, habilidades, objetos, combates y m\u00e1s. \ud83e\uddcd Jugador ( Jugador ) \u00b6 Representa al personaje jugable vinculado al usuario. Campo Tipo Descripci\u00f3n user OneToOneField \u2192 User Usuario asociado nombre CharField Nombre del personaje clase CharField (choices) Clase del personaje (guerrero, mago, etc.) alineacion CharField (choices) Alineaci\u00f3n moral del personaje nivel IntegerField Nivel actual experiencia , experiencia_maxima IntegerField Progreso de experiencia salud , salud_maxima IntegerField Puntos de vida actuales y m\u00e1ximos energia_espiritual , energia_espiritual_maxima IntegerField Recurso para usar habilidades ataque , defensa , velocidad IntegerField Estad\u00edsticas base oro IntegerField Moneda (puntuaci\u00f3n) acumulada arma , accesorio ForeignKey Equipo en uso habilidad_1/2/3 ForeignKey \u2192 Activa Habilidades activas habilidad_pasiva ForeignKey \u2192 Pasiva Habilidad pasiva \u00fanica victorias , derrotas IntegerField Registro de combates combate_abandonado BooleanField Flag para combates interrumpidos (sin usar) combate_abandonado_id IntegerField ID del combate pendiente \u2694\ufe0f Armas y Accesorios \u00b6 Arma \u00b6 Armas equipables que afectan al ataque, defensa o velocidad. Campo Tipo Descripci\u00f3n nombre CharField Nombre del arma foto ImageField Imagen representativa ataque , defensa , velocidad IntegerField Modificadores nivel_necesario IntegerField Nivel m\u00ednimo requerido Accesorio \u00b6 Complementos que mejoran m\u00faltiples estad\u00edsticas. Campo Tipo Descripci\u00f3n salud , energia_espiritual , defensa , velocidad , ataque IntegerField Bonificaciones nivel_necesario IntegerField Requisito m\u00ednimo de nivel \u2728 Habilidades \u00b6 Pasiva \u00b6 Habilidad \u00fanica que otorga beneficios permanentes al jugador. Campo Tipo Descripci\u00f3n nombre CharField Identificador descripcion TextField Descripci\u00f3n textual efecto JSONField Define los modificadores aplicados Activa \u00b6 Habilidad que consume energ\u00eda o salud para aplicar efectos. Campo Tipo Descripci\u00f3n nombre CharField Nombre visible descripcion TextField Descripci\u00f3n del efecto coste_energia , coste_salud IntegerField Coste al usar efecto JSONField JSON con efectos de la habilidad nivel_necesario IntegerField Nivel requerido para usar la habilidad ActivaEnemigo \u00b6 Versi\u00f3n ligera de Activa usada por enemigos. Campo Tipo Descripci\u00f3n nombre , descripcion CharField/TextField Datos base efecto JSONField JSON con efectos de la habilidad \ud83d\ude08 Enemigos \u00b6 Enemigo \u00b6 Entidad b\u00e1sica de combate. Campo Tipo Descripci\u00f3n nombre , descripcion , imagen Texto/Imagen Identidad visual salud , ataque , defensa , velocidad IntegerField Estad\u00edsticas dificultad , nivel IntegerField Escalado de combate habilidad_1/2/3 ForeignKey \u2192 ActivaEnemigo T\u00e9cnicas que puede usar experiencia_otorgada , oro_otorgado IntegerField Recompensas recompensa_especial JSONField \u00cdtems o condiciones Jefe (Sin uso actualmente) \u00b6 Extiende Enemigo para jefes de alta dificultad. Campo Tipo Descripci\u00f3n habilidades JSONField Lista de habilidades din\u00e1micas es_jefe_final BooleanField Flag para jefe de campa\u00f1a \u2694\ufe0f Combate ( Combate ) \u00b6 Guarda el estado de una batalla. Campo Tipo Descripci\u00f3n nombre CharField T\u00edtulo o referencia jugador ForeignKey \u2192 Jugador Participante jugador enemigo ForeignKey \u2192 Enemigo Enemigo del combate registro TextField Historial de eventos turnos IntegerField N\u00famero de turnos elapsados cooldowns_enemigo JSONField Seguimiento de habilidades terminado BooleanField Si el combate ha finalizado resultado CharField Victoria / Derrota \ud83c\udf0d Mapa y Ubicaciones \u00b6 Ubicacion (Sin uso actualmente) \u00b6 Posici\u00f3n en el mapa del mundo. Campo Tipo Descripci\u00f3n nombre CharField Nombre de la regi\u00f3n o zona coordenadas CharField Para su posici\u00f3n en el mapa visual tipo CharField (choices) Puede ser \"combate\", \"dialogo\", \"plantilla\" enemigo FK opcional \u2192 Enemigo Si es zona de combate plantilla_destino CharField Redirecci\u00f3n interna texto_dialogo TextField Narraci\u00f3n mostrada si es tipo di\u00e1logo \ud83e\uddea Modelos comentados / no activos \u00b6 Tambi\u00e9n incluye varios modelos desactivados, se usar\u00e1n en el futuro: Objeto , Mochila , ObjetoEnMochila : sistema de inventario (por implementar). Estado , EstadoActivo : control de estados aplicados en combate. HiddenPotential , HiddenPotentialNodeTemplate : posible sistema de mejora tipo \"\u00e1rbol de talentos\". \ud83e\udde0 Consideraciones t\u00e9cnicas \u00b6 El uso de JSONField otorga flexibilidad para representar efectos y recompensas. Las relaciones ForeignKey y OneToOneField estructuran perfectamente los datos. Se usa ImageField para enriquecer visualmente la experiencia en el frontend (Aunque actualmente no hay ninguna imagen a\u00f1adida, pero la idea es esa). La l\u00f3gica est\u00e1 dise\u00f1ada para permitir f\u00e1cil ampliaci\u00f3n de funcionalidades futuras. \u2705 Los modelos sirven como columna vertebral del juego: representan al jugador, sus enemigos, sus batallas, y todo el ecosistema de habilidades y objetos.","title":"\ud83d\udce6 Modelos del Proyecto"},{"location":"modelos/#modelos-del-proyecto","text":"Esta secci\u00f3n documenta todos los modelos utilizados en Battlebound Tactics , el videojuego web RPG de combate por turnos. Los modelos est\u00e1n definidos en Django ORM y conforman la base de datos del juego, incluyendo jugadores, enemigos, habilidades, objetos, combates y m\u00e1s.","title":"\ud83e\uddec Modelos del Proyecto"},{"location":"modelos/#jugador-jugador","text":"Representa al personaje jugable vinculado al usuario. Campo Tipo Descripci\u00f3n user OneToOneField \u2192 User Usuario asociado nombre CharField Nombre del personaje clase CharField (choices) Clase del personaje (guerrero, mago, etc.) alineacion CharField (choices) Alineaci\u00f3n moral del personaje nivel IntegerField Nivel actual experiencia , experiencia_maxima IntegerField Progreso de experiencia salud , salud_maxima IntegerField Puntos de vida actuales y m\u00e1ximos energia_espiritual , energia_espiritual_maxima IntegerField Recurso para usar habilidades ataque , defensa , velocidad IntegerField Estad\u00edsticas base oro IntegerField Moneda (puntuaci\u00f3n) acumulada arma , accesorio ForeignKey Equipo en uso habilidad_1/2/3 ForeignKey \u2192 Activa Habilidades activas habilidad_pasiva ForeignKey \u2192 Pasiva Habilidad pasiva \u00fanica victorias , derrotas IntegerField Registro de combates combate_abandonado BooleanField Flag para combates interrumpidos (sin usar) combate_abandonado_id IntegerField ID del combate pendiente","title":"\ud83e\uddcd Jugador (Jugador)"},{"location":"modelos/#armas-y-accesorios","text":"","title":"\u2694\ufe0f Armas y Accesorios"},{"location":"modelos/#arma","text":"Armas equipables que afectan al ataque, defensa o velocidad. Campo Tipo Descripci\u00f3n nombre CharField Nombre del arma foto ImageField Imagen representativa ataque , defensa , velocidad IntegerField Modificadores nivel_necesario IntegerField Nivel m\u00ednimo requerido","title":"Arma"},{"location":"modelos/#accesorio","text":"Complementos que mejoran m\u00faltiples estad\u00edsticas. Campo Tipo Descripci\u00f3n salud , energia_espiritual , defensa , velocidad , ataque IntegerField Bonificaciones nivel_necesario IntegerField Requisito m\u00ednimo de nivel","title":"Accesorio"},{"location":"modelos/#habilidades","text":"","title":"\u2728 Habilidades"},{"location":"modelos/#pasiva","text":"Habilidad \u00fanica que otorga beneficios permanentes al jugador. Campo Tipo Descripci\u00f3n nombre CharField Identificador descripcion TextField Descripci\u00f3n textual efecto JSONField Define los modificadores aplicados","title":"Pasiva"},{"location":"modelos/#activa","text":"Habilidad que consume energ\u00eda o salud para aplicar efectos. Campo Tipo Descripci\u00f3n nombre CharField Nombre visible descripcion TextField Descripci\u00f3n del efecto coste_energia , coste_salud IntegerField Coste al usar efecto JSONField JSON con efectos de la habilidad nivel_necesario IntegerField Nivel requerido para usar la habilidad","title":"Activa"},{"location":"modelos/#activaenemigo","text":"Versi\u00f3n ligera de Activa usada por enemigos. Campo Tipo Descripci\u00f3n nombre , descripcion CharField/TextField Datos base efecto JSONField JSON con efectos de la habilidad","title":"ActivaEnemigo"},{"location":"modelos/#enemigos","text":"","title":"\ud83d\ude08 Enemigos"},{"location":"modelos/#enemigo","text":"Entidad b\u00e1sica de combate. Campo Tipo Descripci\u00f3n nombre , descripcion , imagen Texto/Imagen Identidad visual salud , ataque , defensa , velocidad IntegerField Estad\u00edsticas dificultad , nivel IntegerField Escalado de combate habilidad_1/2/3 ForeignKey \u2192 ActivaEnemigo T\u00e9cnicas que puede usar experiencia_otorgada , oro_otorgado IntegerField Recompensas recompensa_especial JSONField \u00cdtems o condiciones","title":"Enemigo"},{"location":"modelos/#jefe-sin-uso-actualmente","text":"Extiende Enemigo para jefes de alta dificultad. Campo Tipo Descripci\u00f3n habilidades JSONField Lista de habilidades din\u00e1micas es_jefe_final BooleanField Flag para jefe de campa\u00f1a","title":"Jefe (Sin uso actualmente)"},{"location":"modelos/#combate-combate","text":"Guarda el estado de una batalla. Campo Tipo Descripci\u00f3n nombre CharField T\u00edtulo o referencia jugador ForeignKey \u2192 Jugador Participante jugador enemigo ForeignKey \u2192 Enemigo Enemigo del combate registro TextField Historial de eventos turnos IntegerField N\u00famero de turnos elapsados cooldowns_enemigo JSONField Seguimiento de habilidades terminado BooleanField Si el combate ha finalizado resultado CharField Victoria / Derrota","title":"\u2694\ufe0f Combate (Combate)"},{"location":"modelos/#mapa-y-ubicaciones","text":"","title":"\ud83c\udf0d Mapa y Ubicaciones"},{"location":"modelos/#ubicacion-sin-uso-actualmente","text":"Posici\u00f3n en el mapa del mundo. Campo Tipo Descripci\u00f3n nombre CharField Nombre de la regi\u00f3n o zona coordenadas CharField Para su posici\u00f3n en el mapa visual tipo CharField (choices) Puede ser \"combate\", \"dialogo\", \"plantilla\" enemigo FK opcional \u2192 Enemigo Si es zona de combate plantilla_destino CharField Redirecci\u00f3n interna texto_dialogo TextField Narraci\u00f3n mostrada si es tipo di\u00e1logo","title":"Ubicacion (Sin uso actualmente)"},{"location":"modelos/#modelos-comentados-no-activos","text":"Tambi\u00e9n incluye varios modelos desactivados, se usar\u00e1n en el futuro: Objeto , Mochila , ObjetoEnMochila : sistema de inventario (por implementar). Estado , EstadoActivo : control de estados aplicados en combate. HiddenPotential , HiddenPotentialNodeTemplate : posible sistema de mejora tipo \"\u00e1rbol de talentos\".","title":"\ud83e\uddea Modelos comentados / no activos"},{"location":"modelos/#consideraciones-tecnicas","text":"El uso de JSONField otorga flexibilidad para representar efectos y recompensas. Las relaciones ForeignKey y OneToOneField estructuran perfectamente los datos. Se usa ImageField para enriquecer visualmente la experiencia en el frontend (Aunque actualmente no hay ninguna imagen a\u00f1adida, pero la idea es esa). La l\u00f3gica est\u00e1 dise\u00f1ada para permitir f\u00e1cil ampliaci\u00f3n de funcionalidades futuras. \u2705 Los modelos sirven como columna vertebral del juego: representan al jugador, sus enemigos, sus batallas, y todo el ecosistema de habilidades y objetos.","title":"\ud83e\udde0 Consideraciones t\u00e9cnicas"},{"location":"vistas/","text":"\ud83c\udf10 Vistas de Django \u00b6 Esta secci\u00f3n documenta en detalle cada una de las vistas del proyecto, mostrando los par\u00e1metros recibidos y decoradores aplicados. Aqu\u00ed explico c\u00f3mo cada vista contribuye a la funcionalidad del juego. \ud83d\uddbc\ufe0f BienvenidaPageView(request) \u00b6 Decoradores : Ninguno Par\u00e1metros : request Vista de tipo TemplateView que carga la plantilla de bienvenida. Es la pantalla inicial que ve el usuario antes de iniciar sesi\u00f3n o registrarse. No requiere autenticaci\u00f3n. \ud83c\udfe0 InicioPageView(request) \u00b6 Decoradores : LoginRequiredMixin Par\u00e1metros : request Esta vista principal se muestra tras iniciar sesi\u00f3n. Calcula el porcentaje de salud, energ\u00eda y experiencia del jugador para mostrarlos gr\u00e1ficamente. Tambi\u00e9n muestra las rutas disponibles: mapa, fuente, equipo, habilidades y ranking. \ud83d\uddfa\ufe0f MapaContinentePageView(request) \u00b6 Decoradores : LoginRequiredMixin Par\u00e1metros : request Muestra el mapa general del continente. Es una plantilla est\u00e1tica que permite al jugador seleccionar una regi\u00f3n espec\u00edfica para explorar. \ud83c\udf0d RegionPageView(request) \u00b6 Decoradores : LoginRequiredMixin Par\u00e1metros : request Muestra una regi\u00f3n concreta con enemigos aleatorios. Excluye jefes (salvo uno especial que s\u00ed puede aparecer en una ubicaci\u00f3n preseleccionada) y muestra siete enemigos diferentes. Cada zona del mapa puede presentar un enemigo distinto. \ud83d\udc64 RegistroPageView(request) \u00b6 Decoradores : Ninguno Par\u00e1metros : request Vista basada en formularios ( FormView ) que gestiona el registro del usuario. Crea un usuario en base al modelo Jugador , le asigna una pasiva aleatoria y luego inicia sesi\u00f3n autom\u00e1ticamente con login . \ud83d\udd10 LoginUserView(request) \u00b6 Decoradores : Ninguno Par\u00e1metros : request Vista heredada de LoginView de Django. Muestra el formulario de login de usuarios, cuenta con una plantilla personalizada. \ud83c\udfc6 RankingPageView(request) \u00b6 Decoradores : LoginRequiredMixin Par\u00e1metros : request Muestra el ranking general de jugadores. Aqu\u00ed mostramos los 5 mejores jugadores ordenados por categor\u00edas (oro, victorias, derrotas y nivel), esto lo hacemos mediante el uso de una API propia que contiene esta informaci\u00f3n. \ud83c\udff0 CastlevyrPageView(request) \u00b6 Decoradores : LoginRequiredMixin Par\u00e1metros : request Vista que representa el castillo final del juego. Carga un jefe espec\u00edfico llamado \"Havva Skript\" y prepara al jugador para enfrentarlo. Esta vista representa el punto culminante de la versi\u00f3n actual del juego. \u2694\ufe0f equipamiento(request) \u00b6 Decoradores : @login_required Par\u00e1metros : request Permite al jugador cambiar su arma o accesorio. Verifica que el jugador tenga el nivel necesario antes de aplicar los cambios. Carga todos los objetos disponibles y actualiza a nuestro jugador. \ud83d\udcda habilidades(request) \u00b6 Decoradores : @login_required Par\u00e1metros : request Permite al jugador gestionar sus habilidades. Valida si cuenta con el nivel necesario para equiparlas y permite sustituir cualquiera de las tres ranuras disponibles. Usa el modelo Activa . \u2694\ufe0f iniciar_combate(request, enemigo_id) \u00b6 Decoradores : @login_required , @require_GET Par\u00e1metros : request , enemigo_id Inicializa un nuevo combate contra el enemigo seleccionado. Crea una instancia del modelo Combate , guardando el jugador y el enemigo involucrados, y redirige a la vista combate . \ud83e\udde0 combate(request, combate_id) \u00b6 Decoradores : @login_required Par\u00e1metros : request , combate_id Vista central de combate por turnos. Controla la l\u00f3gica del enfrentamiento: Aplica efectos de estado Determina el orden de turnos por velocidad Ejecuta acciones del jugador y del enemigo Registra logs y efectos visuales Actualiza el turno en el modelo Combate Trabaja con m\u00faltiples m\u00f3dulos del n\u00facleo ( estadisticas.py , jugador.py , enemigos.py , efectos.py , utils_resolvedor.py ) y es la pieza m\u00e1s importante de la mec\u00e1nica del juego. Para m\u00e1s detalles, por favor, consulte nuestra \u2694\ufe0f L\u00f3gica del Combate \ud83c\udfaf resultado_combate(request, combate_id) \u00b6 Decoradores : ninguno Par\u00e1metros : request , combate_id Muestra el resultado final del combate: victoria o derrota. Carga todos los datos relevantes desde la instancia del modelo Combate y los pasa a la plantilla resultado.html . \ud83d\udca7 fuente(request) \u00b6 Decoradores : ninguno Par\u00e1metros : request Restaura completamente la salud y energ\u00eda del jugador, luego, redirige al inicio . \ud83d\udee0\ufe0f Comentadas: abandonar_combate, verificar_abandono, resolver_abandono \u00b6 Decoradores : (comentados) Par\u00e1metros : varios Estas funciones est\u00e1n desactivadas actualmente, pero estaban dise\u00f1adas para registrar el abandono de un combate. Incluyen opciones para continuar o rendirse, y estaban pensadas para prevenir exploits o fallos en el flujo de batalla.","title":"\ud83d\udda5\ufe0f Vistas de Django"},{"location":"vistas/#vistas-de-django","text":"Esta secci\u00f3n documenta en detalle cada una de las vistas del proyecto, mostrando los par\u00e1metros recibidos y decoradores aplicados. Aqu\u00ed explico c\u00f3mo cada vista contribuye a la funcionalidad del juego.","title":"\ud83c\udf10 Vistas de Django"},{"location":"vistas/#bienvenidapageviewrequest","text":"Decoradores : Ninguno Par\u00e1metros : request Vista de tipo TemplateView que carga la plantilla de bienvenida. Es la pantalla inicial que ve el usuario antes de iniciar sesi\u00f3n o registrarse. No requiere autenticaci\u00f3n.","title":"\ud83d\uddbc\ufe0f BienvenidaPageView(request)"},{"location":"vistas/#iniciopageviewrequest","text":"Decoradores : LoginRequiredMixin Par\u00e1metros : request Esta vista principal se muestra tras iniciar sesi\u00f3n. Calcula el porcentaje de salud, energ\u00eda y experiencia del jugador para mostrarlos gr\u00e1ficamente. Tambi\u00e9n muestra las rutas disponibles: mapa, fuente, equipo, habilidades y ranking.","title":"\ud83c\udfe0 InicioPageView(request)"},{"location":"vistas/#mapacontinentepageviewrequest","text":"Decoradores : LoginRequiredMixin Par\u00e1metros : request Muestra el mapa general del continente. Es una plantilla est\u00e1tica que permite al jugador seleccionar una regi\u00f3n espec\u00edfica para explorar.","title":"\ud83d\uddfa\ufe0f MapaContinentePageView(request)"},{"location":"vistas/#regionpageviewrequest","text":"Decoradores : LoginRequiredMixin Par\u00e1metros : request Muestra una regi\u00f3n concreta con enemigos aleatorios. Excluye jefes (salvo uno especial que s\u00ed puede aparecer en una ubicaci\u00f3n preseleccionada) y muestra siete enemigos diferentes. Cada zona del mapa puede presentar un enemigo distinto.","title":"\ud83c\udf0d RegionPageView(request)"},{"location":"vistas/#registropageviewrequest","text":"Decoradores : Ninguno Par\u00e1metros : request Vista basada en formularios ( FormView ) que gestiona el registro del usuario. Crea un usuario en base al modelo Jugador , le asigna una pasiva aleatoria y luego inicia sesi\u00f3n autom\u00e1ticamente con login .","title":"\ud83d\udc64 RegistroPageView(request)"},{"location":"vistas/#loginuserviewrequest","text":"Decoradores : Ninguno Par\u00e1metros : request Vista heredada de LoginView de Django. Muestra el formulario de login de usuarios, cuenta con una plantilla personalizada.","title":"\ud83d\udd10 LoginUserView(request)"},{"location":"vistas/#rankingpageviewrequest","text":"Decoradores : LoginRequiredMixin Par\u00e1metros : request Muestra el ranking general de jugadores. Aqu\u00ed mostramos los 5 mejores jugadores ordenados por categor\u00edas (oro, victorias, derrotas y nivel), esto lo hacemos mediante el uso de una API propia que contiene esta informaci\u00f3n.","title":"\ud83c\udfc6 RankingPageView(request)"},{"location":"vistas/#castlevyrpageviewrequest","text":"Decoradores : LoginRequiredMixin Par\u00e1metros : request Vista que representa el castillo final del juego. Carga un jefe espec\u00edfico llamado \"Havva Skript\" y prepara al jugador para enfrentarlo. Esta vista representa el punto culminante de la versi\u00f3n actual del juego.","title":"\ud83c\udff0 CastlevyrPageView(request)"},{"location":"vistas/#equipamientorequest","text":"Decoradores : @login_required Par\u00e1metros : request Permite al jugador cambiar su arma o accesorio. Verifica que el jugador tenga el nivel necesario antes de aplicar los cambios. Carga todos los objetos disponibles y actualiza a nuestro jugador.","title":"\u2694\ufe0f equipamiento(request)"},{"location":"vistas/#habilidadesrequest","text":"Decoradores : @login_required Par\u00e1metros : request Permite al jugador gestionar sus habilidades. Valida si cuenta con el nivel necesario para equiparlas y permite sustituir cualquiera de las tres ranuras disponibles. Usa el modelo Activa .","title":"\ud83d\udcda habilidades(request)"},{"location":"vistas/#iniciar_combaterequest-enemigo_id","text":"Decoradores : @login_required , @require_GET Par\u00e1metros : request , enemigo_id Inicializa un nuevo combate contra el enemigo seleccionado. Crea una instancia del modelo Combate , guardando el jugador y el enemigo involucrados, y redirige a la vista combate .","title":"\u2694\ufe0f iniciar_combate(request, enemigo_id)"},{"location":"vistas/#combaterequest-combate_id","text":"Decoradores : @login_required Par\u00e1metros : request , combate_id Vista central de combate por turnos. Controla la l\u00f3gica del enfrentamiento: Aplica efectos de estado Determina el orden de turnos por velocidad Ejecuta acciones del jugador y del enemigo Registra logs y efectos visuales Actualiza el turno en el modelo Combate Trabaja con m\u00faltiples m\u00f3dulos del n\u00facleo ( estadisticas.py , jugador.py , enemigos.py , efectos.py , utils_resolvedor.py ) y es la pieza m\u00e1s importante de la mec\u00e1nica del juego. Para m\u00e1s detalles, por favor, consulte nuestra \u2694\ufe0f L\u00f3gica del Combate","title":"\ud83e\udde0 combate(request, combate_id)"},{"location":"vistas/#resultado_combaterequest-combate_id","text":"Decoradores : ninguno Par\u00e1metros : request , combate_id Muestra el resultado final del combate: victoria o derrota. Carga todos los datos relevantes desde la instancia del modelo Combate y los pasa a la plantilla resultado.html .","title":"\ud83c\udfaf resultado_combate(request, combate_id)"},{"location":"vistas/#fuenterequest","text":"Decoradores : ninguno Par\u00e1metros : request Restaura completamente la salud y energ\u00eda del jugador, luego, redirige al inicio .","title":"\ud83d\udca7 fuente(request)"},{"location":"vistas/#comentadas-abandonar_combate-verificar_abandono-resolver_abandono","text":"Decoradores : (comentados) Par\u00e1metros : varios Estas funciones est\u00e1n desactivadas actualmente, pero estaban dise\u00f1adas para registrar el abandono de un combate. Incluyen opciones para continuar o rendirse, y estaban pensadas para prevenir exploits o fallos en el flujo de batalla.","title":"\ud83d\udee0\ufe0f Comentadas: abandonar_combate, verificar_abandono, resolver_abandono"}]}